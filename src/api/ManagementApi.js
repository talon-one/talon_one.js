/**
 * Talon.One API
 * The Talon.One API is used to manage applications and campaigns, as well as to integrate with your application. The operations in the _Integration API_ section are used to integrate with our platform, while the other operations are used to manage applications and campaigns.  ### Where is the API?  The API is available at the same hostname as these docs. For example, if you are reading this page at `https://mycompany.talon.one/docs/api/`, the URL for the [updateCustomerProfile][] operation is `https://mycompany.talon.one/v1/customer_profiles/id`  [updateCustomerProfile]: #operation--v1-customer_profiles--integrationId--put 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */


import ApiClient from "../ApiClient";
import Account from '../model/Account';
import AccountAdditionalCost from '../model/AccountAdditionalCost';
import AccountAnalytics from '../model/AccountAnalytics';
import Application from '../model/Application';
import ApplicationApiHealth from '../model/ApplicationApiHealth';
import ApplicationCustomer from '../model/ApplicationCustomer';
import ApplicationCustomerSearch from '../model/ApplicationCustomerSearch';
import ApplicationSession from '../model/ApplicationSession';
import Attribute from '../model/Attribute';
import Campaign from '../model/Campaign';
import CampaignCopy from '../model/CampaignCopy';
import CampaignSearch from '../model/CampaignSearch';
import CampaignSet from '../model/CampaignSet';
import Coupon from '../model/Coupon';
import CouponSearch from '../model/CouponSearch';
import CustomerActivityReport from '../model/CustomerActivityReport';
import CustomerAnalytics from '../model/CustomerAnalytics';
import InlineResponse2001 from '../model/InlineResponse2001';
import InlineResponse20010 from '../model/InlineResponse20010';
import InlineResponse20011 from '../model/InlineResponse20011';
import InlineResponse20012 from '../model/InlineResponse20012';
import InlineResponse20013 from '../model/InlineResponse20013';
import InlineResponse20014 from '../model/InlineResponse20014';
import InlineResponse20015 from '../model/InlineResponse20015';
import InlineResponse20016 from '../model/InlineResponse20016';
import InlineResponse20017 from '../model/InlineResponse20017';
import InlineResponse20018 from '../model/InlineResponse20018';
import InlineResponse20019 from '../model/InlineResponse20019';
import InlineResponse2002 from '../model/InlineResponse2002';
import InlineResponse20020 from '../model/InlineResponse20020';
import InlineResponse20021 from '../model/InlineResponse20021';
import InlineResponse20022 from '../model/InlineResponse20022';
import InlineResponse20023 from '../model/InlineResponse20023';
import InlineResponse20024 from '../model/InlineResponse20024';
import InlineResponse20025 from '../model/InlineResponse20025';
import InlineResponse20026 from '../model/InlineResponse20026';
import InlineResponse20027 from '../model/InlineResponse20027';
import InlineResponse20028 from '../model/InlineResponse20028';
import InlineResponse20029 from '../model/InlineResponse20029';
import InlineResponse2003 from '../model/InlineResponse2003';
import InlineResponse20030 from '../model/InlineResponse20030';
import InlineResponse2004 from '../model/InlineResponse2004';
import InlineResponse2005 from '../model/InlineResponse2005';
import InlineResponse2006 from '../model/InlineResponse2006';
import InlineResponse2007 from '../model/InlineResponse2007';
import InlineResponse2008 from '../model/InlineResponse2008';
import InlineResponse2009 from '../model/InlineResponse2009';
import LoginParams from '../model/LoginParams';
import LoyaltyLedger from '../model/LoyaltyLedger';
import LoyaltyPoints from '../model/LoyaltyPoints';
import LoyaltyProgram from '../model/LoyaltyProgram';
import NewAdditionalCost from '../model/NewAdditionalCost';
import NewAttribute from '../model/NewAttribute';
import NewCampaign from '../model/NewCampaign';
import NewCampaignSet from '../model/NewCampaignSet';
import NewCoupons from '../model/NewCoupons';
import NewPassword from '../model/NewPassword';
import NewPasswordEmail from '../model/NewPasswordEmail';
import NewRuleset from '../model/NewRuleset';
import Role from '../model/Role';
import Ruleset from '../model/Ruleset';
import Session from '../model/Session';
import UpdateCampaign from '../model/UpdateCampaign';
import UpdateCoupon from '../model/UpdateCoupon';
import UpdateCouponBatch from '../model/UpdateCouponBatch';
import User from '../model/User';
import Webhook from '../model/Webhook';

/**
* Management service.
* @module api/ManagementApi
* @version 4.0.0
*/
export default class ManagementApi {

    /**
    * Constructs a new ManagementApi. 
    * @alias module:api/ManagementApi
    * @class
    * @param {module:ApiClient} [apiClient] Optional API client implementation to use,
    * default to {@link module:ApiClient#instance} if unspecified.
    */
    constructor(apiClient) {
        this.apiClient = apiClient || ApiClient.instance;
    }



    /**
     * Add points in a certain loyalty program for the specified customer
     * @param {String} programID 
     * @param {String} integrationID 
     * @param {module:model/LoyaltyPoints} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing HTTP response
     */
    addLoyaltyPointsWithHttpInfo(programID, integrationID, body) {
      let postBody = body;
      // verify the required parameter 'programID' is set
      if (programID === undefined || programID === null) {
        throw new Error("Missing the required parameter 'programID' when calling addLoyaltyPoints");
      }
      // verify the required parameter 'integrationID' is set
      if (integrationID === undefined || integrationID === null) {
        throw new Error("Missing the required parameter 'integrationID' when calling addLoyaltyPoints");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling addLoyaltyPoints");
      }

      let pathParams = {
        'programID': programID,
        'integrationID': integrationID
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = ['application/json'];
      let accepts = [];
      let returnType = null;
      return this.apiClient.callApi(
        '/v1/loyalty_programs/{programID}/profile/{integrationID}/add_points', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Add points in a certain loyalty program for the specified customer
     * @param {String} programID 
     * @param {String} integrationID 
     * @param {module:model/LoyaltyPoints} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}
     */
    addLoyaltyPoints(programID, integrationID, body) {
      return this.addLoyaltyPointsWithHttpInfo(programID, integrationID, body)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Copy the campaign into every specified application
     * Copy the campaign into every specified application.
     * @param {Number} applicationId 
     * @param {Number} campaignId 
     * @param {module:model/CampaignCopy} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/InlineResponse2003} and HTTP response
     */
    copyCampaignToApplicationsWithHttpInfo(applicationId, campaignId, body) {
      let postBody = body;
      // verify the required parameter 'applicationId' is set
      if (applicationId === undefined || applicationId === null) {
        throw new Error("Missing the required parameter 'applicationId' when calling copyCampaignToApplications");
      }
      // verify the required parameter 'campaignId' is set
      if (campaignId === undefined || campaignId === null) {
        throw new Error("Missing the required parameter 'campaignId' when calling copyCampaignToApplications");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling copyCampaignToApplications");
      }

      let pathParams = {
        'applicationId': applicationId,
        'campaignId': campaignId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = InlineResponse2003;
      return this.apiClient.callApi(
        '/v1/applications/{applicationId}/campaigns/{campaignId}/copy', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Copy the campaign into every specified application
     * Copy the campaign into every specified application.
     * @param {Number} applicationId 
     * @param {Number} campaignId 
     * @param {module:model/CampaignCopy} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/InlineResponse2003}
     */
    copyCampaignToApplications(applicationId, campaignId, body) {
      return this.copyCampaignToApplicationsWithHttpInfo(applicationId, campaignId, body)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Define a new additional cost
     * Defines a new _additional cost_ in this account.  These additional costs are shared across all applications in your account, and are never required. 
     * @param {module:model/NewAdditionalCost} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/AccountAdditionalCost} and HTTP response
     */
    createAdditionalCostWithHttpInfo(body) {
      let postBody = body;
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling createAdditionalCost");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = AccountAdditionalCost;
      return this.apiClient.callApi(
        '/v1/additional_costs', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Define a new additional cost
     * Defines a new _additional cost_ in this account.  These additional costs are shared across all applications in your account, and are never required. 
     * @param {module:model/NewAdditionalCost} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/AccountAdditionalCost}
     */
    createAdditionalCost(body) {
      return this.createAdditionalCostWithHttpInfo(body)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Define a new custom attribute
     * Defines a new _custom attribute_ in this account. Custom attributes allow you to attach new fields to Talon.One domain objects like campaigns, coupons, customers and so on. These attributes can then be given values when creating / updating these objects, and these values can be used in your campaign rules. For example, you could define a `zipCode` field for customer sessions, and add a rule to your campaign that only allows certain ZIP codes.  These attributes are shared across all applications in your account, and are never required. 
     * @param {module:model/NewAttribute} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/Attribute} and HTTP response
     */
    createAttributeWithHttpInfo(body) {
      let postBody = body;
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling createAttribute");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = Attribute;
      return this.apiClient.callApi(
        '/v1/attributes', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Define a new custom attribute
     * Defines a new _custom attribute_ in this account. Custom attributes allow you to attach new fields to Talon.One domain objects like campaigns, coupons, customers and so on. These attributes can then be given values when creating / updating these objects, and these values can be used in your campaign rules. For example, you could define a `zipCode` field for customer sessions, and add a rule to your campaign that only allows certain ZIP codes.  These attributes are shared across all applications in your account, and are never required. 
     * @param {module:model/NewAttribute} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/Attribute}
     */
    createAttribute(body) {
      return this.createAttributeWithHttpInfo(body)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Create a Campaign
     * @param {Number} applicationId 
     * @param {module:model/NewCampaign} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/Campaign} and HTTP response
     */
    createCampaignWithHttpInfo(applicationId, body) {
      let postBody = body;
      // verify the required parameter 'applicationId' is set
      if (applicationId === undefined || applicationId === null) {
        throw new Error("Missing the required parameter 'applicationId' when calling createCampaign");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling createCampaign");
      }

      let pathParams = {
        'applicationId': applicationId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = Campaign;
      return this.apiClient.callApi(
        '/v1/applications/{applicationId}/campaigns', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Create a Campaign
     * @param {Number} applicationId 
     * @param {module:model/NewCampaign} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/Campaign}
     */
    createCampaign(applicationId, body) {
      return this.createCampaignWithHttpInfo(applicationId, body)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Create Coupons
     * Create coupons according to some pattern. Up to 20.000 coupons can be created without a unique prefix. When a unique prefix is provided, up to 200.000 coupons can be created.
     * @param {Number} applicationId 
     * @param {Number} campaignId 
     * @param {module:model/NewCoupons} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.silent If set to 'yes', response will be an empty 204, otherwise a list of the coupons generated (to to 1000).
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/InlineResponse2001} and HTTP response
     */
    createCouponsWithHttpInfo(applicationId, campaignId, body, opts) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'applicationId' is set
      if (applicationId === undefined || applicationId === null) {
        throw new Error("Missing the required parameter 'applicationId' when calling createCoupons");
      }
      // verify the required parameter 'campaignId' is set
      if (campaignId === undefined || campaignId === null) {
        throw new Error("Missing the required parameter 'campaignId' when calling createCoupons");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling createCoupons");
      }

      let pathParams = {
        'applicationId': applicationId,
        'campaignId': campaignId
      };
      let queryParams = {
        'silent': opts['silent']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = InlineResponse2001;
      return this.apiClient.callApi(
        '/v1/applications/{applicationId}/campaigns/{campaignId}/coupons', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Create Coupons
     * Create coupons according to some pattern. Up to 20.000 coupons can be created without a unique prefix. When a unique prefix is provided, up to 200.000 coupons can be created.
     * @param {Number} applicationId 
     * @param {Number} campaignId 
     * @param {module:model/NewCoupons} body 
     * @param {Object} opts Optional parameters
     * @param {String} opts.silent If set to 'yes', response will be an empty 204, otherwise a list of the coupons generated (to to 1000).
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/InlineResponse2001}
     */
    createCoupons(applicationId, campaignId, body, opts) {
      return this.createCouponsWithHttpInfo(applicationId, campaignId, body, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Request a password reset
     * Sends an email with a password recovery link to the email of an existing account. 
     * @param {module:model/NewPasswordEmail} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/NewPasswordEmail} and HTTP response
     */
    createPasswordRecoveryEmailWithHttpInfo(body) {
      let postBody = body;
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling createPasswordRecoveryEmail");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = NewPasswordEmail;
      return this.apiClient.callApi(
        '/v1/password_recovery_emails', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Request a password reset
     * Sends an email with a password recovery link to the email of an existing account. 
     * @param {module:model/NewPasswordEmail} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/NewPasswordEmail}
     */
    createPasswordRecoveryEmail(body) {
      return this.createPasswordRecoveryEmailWithHttpInfo(body)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Create a Ruleset
     * @param {Number} applicationId 
     * @param {Number} campaignId 
     * @param {module:model/NewRuleset} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/Ruleset} and HTTP response
     */
    createRulesetWithHttpInfo(applicationId, campaignId, body) {
      let postBody = body;
      // verify the required parameter 'applicationId' is set
      if (applicationId === undefined || applicationId === null) {
        throw new Error("Missing the required parameter 'applicationId' when calling createRuleset");
      }
      // verify the required parameter 'campaignId' is set
      if (campaignId === undefined || campaignId === null) {
        throw new Error("Missing the required parameter 'campaignId' when calling createRuleset");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling createRuleset");
      }

      let pathParams = {
        'applicationId': applicationId,
        'campaignId': campaignId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = Ruleset;
      return this.apiClient.callApi(
        '/v1/applications/{applicationId}/campaigns/{campaignId}/rulesets', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Create a Ruleset
     * @param {Number} applicationId 
     * @param {Number} campaignId 
     * @param {module:model/NewRuleset} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/Ruleset}
     */
    createRuleset(applicationId, campaignId, body) {
      return this.createRulesetWithHttpInfo(applicationId, campaignId, body)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Create a Session
     * @param {module:model/LoginParams} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/Session} and HTTP response
     */
    createSessionWithHttpInfo(body) {
      let postBody = body;
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling createSession");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = Session;
      return this.apiClient.callApi(
        '/v1/sessions', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Create a Session
     * @param {module:model/LoginParams} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/Session}
     */
    createSession(body) {
      return this.createSessionWithHttpInfo(body)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Delete a Campaign
     * @param {Number} applicationId 
     * @param {Number} campaignId 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing HTTP response
     */
    deleteCampaignWithHttpInfo(applicationId, campaignId) {
      let postBody = null;
      // verify the required parameter 'applicationId' is set
      if (applicationId === undefined || applicationId === null) {
        throw new Error("Missing the required parameter 'applicationId' when calling deleteCampaign");
      }
      // verify the required parameter 'campaignId' is set
      if (campaignId === undefined || campaignId === null) {
        throw new Error("Missing the required parameter 'campaignId' when calling deleteCampaign");
      }

      let pathParams = {
        'applicationId': applicationId,
        'campaignId': campaignId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = [];
      let accepts = [];
      let returnType = null;
      return this.apiClient.callApi(
        '/v1/applications/{applicationId}/campaigns/{campaignId}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Delete a Campaign
     * @param {Number} applicationId 
     * @param {Number} campaignId 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}
     */
    deleteCampaign(applicationId, campaignId) {
      return this.deleteCampaignWithHttpInfo(applicationId, campaignId)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Delete one Coupon
     * @param {Number} applicationId 
     * @param {Number} campaignId 
     * @param {String} couponId The ID of the coupon code to delete
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing HTTP response
     */
    deleteCouponWithHttpInfo(applicationId, campaignId, couponId) {
      let postBody = null;
      // verify the required parameter 'applicationId' is set
      if (applicationId === undefined || applicationId === null) {
        throw new Error("Missing the required parameter 'applicationId' when calling deleteCoupon");
      }
      // verify the required parameter 'campaignId' is set
      if (campaignId === undefined || campaignId === null) {
        throw new Error("Missing the required parameter 'campaignId' when calling deleteCoupon");
      }
      // verify the required parameter 'couponId' is set
      if (couponId === undefined || couponId === null) {
        throw new Error("Missing the required parameter 'couponId' when calling deleteCoupon");
      }

      let pathParams = {
        'applicationId': applicationId,
        'campaignId': campaignId,
        'couponId': couponId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = [];
      let accepts = [];
      let returnType = null;
      return this.apiClient.callApi(
        '/v1/applications/{applicationId}/campaigns/{campaignId}/coupons/{couponId}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Delete one Coupon
     * @param {Number} applicationId 
     * @param {Number} campaignId 
     * @param {String} couponId The ID of the coupon code to delete
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}
     */
    deleteCoupon(applicationId, campaignId, couponId) {
      return this.deleteCouponWithHttpInfo(applicationId, campaignId, couponId)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Delete Coupons
     * @param {Number} applicationId 
     * @param {Number} campaignId 
     * @param {Object} opts Optional parameters
     * @param {String} opts.value Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters.
     * @param {Date} opts.createdBefore Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
     * @param {Date} opts.createdAfter Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
     * @param {Date} opts.startsAfter Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
     * @param {Date} opts.startsBefore Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
     * @param {Date} opts.expiresAfter Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
     * @param {Date} opts.expiresBefore Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
     * @param {module:model/String} opts.valid Either \"expired\", \"validNow\", or \"validFuture\". The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. 
     * @param {String} opts.batchId Filter results by batches of coupons
     * @param {module:model/String} opts.usable Either \"true\" or \"false\". If \"true\", only coupons where `usageCounter < usageLimit` will be returned, \"false\" will return only coupons where `usageCounter >= usageLimit`. 
     * @param {Number} opts.referralId Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code.
     * @param {String} opts.recipientIntegrationId Filter results by match with a profile id specified in the coupon's RecipientIntegrationId field
     * @param {Boolean} opts.exactMatch Filter results to an exact case-insensitive matching against the coupon code (default to false)
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing HTTP response
     */
    deleteCouponsWithHttpInfo(applicationId, campaignId, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'applicationId' is set
      if (applicationId === undefined || applicationId === null) {
        throw new Error("Missing the required parameter 'applicationId' when calling deleteCoupons");
      }
      // verify the required parameter 'campaignId' is set
      if (campaignId === undefined || campaignId === null) {
        throw new Error("Missing the required parameter 'campaignId' when calling deleteCoupons");
      }

      let pathParams = {
        'applicationId': applicationId,
        'campaignId': campaignId
      };
      let queryParams = {
        'value': opts['value'],
        'createdBefore': opts['createdBefore'],
        'createdAfter': opts['createdAfter'],
        'startsAfter': opts['startsAfter'],
        'startsBefore': opts['startsBefore'],
        'expiresAfter': opts['expiresAfter'],
        'expiresBefore': opts['expiresBefore'],
        'valid': opts['valid'],
        'batchId': opts['batchId'],
        'usable': opts['usable'],
        'referralId': opts['referralId'],
        'recipientIntegrationId': opts['recipientIntegrationId'],
        'exactMatch': opts['exactMatch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = [];
      let accepts = [];
      let returnType = null;
      return this.apiClient.callApi(
        '/v1/applications/{applicationId}/campaigns/{campaignId}/coupons', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Delete Coupons
     * @param {Number} applicationId 
     * @param {Number} campaignId 
     * @param {Object} opts Optional parameters
     * @param {String} opts.value Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters.
     * @param {Date} opts.createdBefore Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
     * @param {Date} opts.createdAfter Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
     * @param {Date} opts.startsAfter Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
     * @param {Date} opts.startsBefore Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
     * @param {Date} opts.expiresAfter Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
     * @param {Date} opts.expiresBefore Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
     * @param {module:model/String} opts.valid Either \"expired\", \"validNow\", or \"validFuture\". The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. 
     * @param {String} opts.batchId Filter results by batches of coupons
     * @param {module:model/String} opts.usable Either \"true\" or \"false\". If \"true\", only coupons where `usageCounter < usageLimit` will be returned, \"false\" will return only coupons where `usageCounter >= usageLimit`. 
     * @param {Number} opts.referralId Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code.
     * @param {String} opts.recipientIntegrationId Filter results by match with a profile id specified in the coupon's RecipientIntegrationId field
     * @param {Boolean} opts.exactMatch Filter results to an exact case-insensitive matching against the coupon code (default to false)
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}
     */
    deleteCoupons(applicationId, campaignId, opts) {
      return this.deleteCouponsWithHttpInfo(applicationId, campaignId, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Delete one Referral
     * @param {Number} applicationId 
     * @param {Number} campaignId 
     * @param {String} referralId The ID of the referral code to delete
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing HTTP response
     */
    deleteReferralWithHttpInfo(applicationId, campaignId, referralId) {
      let postBody = null;
      // verify the required parameter 'applicationId' is set
      if (applicationId === undefined || applicationId === null) {
        throw new Error("Missing the required parameter 'applicationId' when calling deleteReferral");
      }
      // verify the required parameter 'campaignId' is set
      if (campaignId === undefined || campaignId === null) {
        throw new Error("Missing the required parameter 'campaignId' when calling deleteReferral");
      }
      // verify the required parameter 'referralId' is set
      if (referralId === undefined || referralId === null) {
        throw new Error("Missing the required parameter 'referralId' when calling deleteReferral");
      }

      let pathParams = {
        'applicationId': applicationId,
        'campaignId': campaignId,
        'referralId': referralId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = [];
      let accepts = [];
      let returnType = null;
      return this.apiClient.callApi(
        '/v1/applications/{applicationId}/campaigns/{campaignId}/referrals/{referralId}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Delete one Referral
     * @param {Number} applicationId 
     * @param {Number} campaignId 
     * @param {String} referralId The ID of the referral code to delete
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}
     */
    deleteReferral(applicationId, campaignId, referralId) {
      return this.deleteReferralWithHttpInfo(applicationId, campaignId, referralId)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Delete a Ruleset
     * @param {Number} applicationId 
     * @param {Number} campaignId 
     * @param {Number} rulesetId 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing HTTP response
     */
    deleteRulesetWithHttpInfo(applicationId, campaignId, rulesetId) {
      let postBody = null;
      // verify the required parameter 'applicationId' is set
      if (applicationId === undefined || applicationId === null) {
        throw new Error("Missing the required parameter 'applicationId' when calling deleteRuleset");
      }
      // verify the required parameter 'campaignId' is set
      if (campaignId === undefined || campaignId === null) {
        throw new Error("Missing the required parameter 'campaignId' when calling deleteRuleset");
      }
      // verify the required parameter 'rulesetId' is set
      if (rulesetId === undefined || rulesetId === null) {
        throw new Error("Missing the required parameter 'rulesetId' when calling deleteRuleset");
      }

      let pathParams = {
        'applicationId': applicationId,
        'campaignId': campaignId,
        'rulesetId': rulesetId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = [];
      let accepts = [];
      let returnType = null;
      return this.apiClient.callApi(
        '/v1/applications/{applicationId}/campaigns/{campaignId}/rulesets/{rulesetId}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Delete a Ruleset
     * @param {Number} applicationId 
     * @param {Number} campaignId 
     * @param {Number} rulesetId 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}
     */
    deleteRuleset(applicationId, campaignId, rulesetId) {
      return this.deleteRulesetWithHttpInfo(applicationId, campaignId, rulesetId)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get access logs for application
     * @param {Number} applicationId 
     * @param {Date} rangeStart Only return results from after this timestamp, must be an RFC3339 timestamp string
     * @param {Date} rangeEnd Only return results from before this timestamp, must be an RFC3339 timestamp string
     * @param {Object} opts Optional parameters
     * @param {String} opts.path Only return results where the request path matches the given regular expression.
     * @param {module:model/String} opts.method Only return results where the request method matches the given regular expression.
     * @param {module:model/String} opts.status Filter results by HTTP status codes.
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @param {String} opts.sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/InlineResponse2009} and HTTP response
     */
    getAccessLogsWithHttpInfo(applicationId, rangeStart, rangeEnd, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'applicationId' is set
      if (applicationId === undefined || applicationId === null) {
        throw new Error("Missing the required parameter 'applicationId' when calling getAccessLogs");
      }
      // verify the required parameter 'rangeStart' is set
      if (rangeStart === undefined || rangeStart === null) {
        throw new Error("Missing the required parameter 'rangeStart' when calling getAccessLogs");
      }
      // verify the required parameter 'rangeEnd' is set
      if (rangeEnd === undefined || rangeEnd === null) {
        throw new Error("Missing the required parameter 'rangeEnd' when calling getAccessLogs");
      }

      let pathParams = {
        'applicationId': applicationId
      };
      let queryParams = {
        'path': opts['path'],
        'method': opts['method'],
        'status': opts['status'],
        'rangeStart': rangeStart,
        'rangeEnd': rangeEnd,
        'pageSize': opts['pageSize'],
        'skip': opts['skip'],
        'sort': opts['sort']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = InlineResponse2009;
      return this.apiClient.callApi(
        '/v1/applications/{applicationId}/access_logs', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get access logs for application
     * @param {Number} applicationId 
     * @param {Date} rangeStart Only return results from after this timestamp, must be an RFC3339 timestamp string
     * @param {Date} rangeEnd Only return results from before this timestamp, must be an RFC3339 timestamp string
     * @param {Object} opts Optional parameters
     * @param {String} opts.path Only return results where the request path matches the given regular expression.
     * @param {module:model/String} opts.method Only return results where the request method matches the given regular expression.
     * @param {module:model/String} opts.status Filter results by HTTP status codes.
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @param {String} opts.sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/InlineResponse2009}
     */
    getAccessLogs(applicationId, rangeStart, rangeEnd, opts) {
      return this.getAccessLogsWithHttpInfo(applicationId, rangeStart, rangeEnd, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get access logs for application
     * @param {Number} applicationId 
     * @param {Date} rangeStart Only return results from after this timestamp, must be an RFC3339 timestamp string
     * @param {Date} rangeEnd Only return results from before this timestamp, must be an RFC3339 timestamp string
     * @param {Object} opts Optional parameters
     * @param {String} opts.path Only return results where the request path matches the given regular expression.
     * @param {module:model/String} opts.method Only return results where the request method matches the given regular expression.
     * @param {module:model/String} opts.status Filter results by HTTP status codes.
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @param {String} opts.sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/InlineResponse20010} and HTTP response
     */
    getAccessLogsWithoutTotalCountWithHttpInfo(applicationId, rangeStart, rangeEnd, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'applicationId' is set
      if (applicationId === undefined || applicationId === null) {
        throw new Error("Missing the required parameter 'applicationId' when calling getAccessLogsWithoutTotalCount");
      }
      // verify the required parameter 'rangeStart' is set
      if (rangeStart === undefined || rangeStart === null) {
        throw new Error("Missing the required parameter 'rangeStart' when calling getAccessLogsWithoutTotalCount");
      }
      // verify the required parameter 'rangeEnd' is set
      if (rangeEnd === undefined || rangeEnd === null) {
        throw new Error("Missing the required parameter 'rangeEnd' when calling getAccessLogsWithoutTotalCount");
      }

      let pathParams = {
        'applicationId': applicationId
      };
      let queryParams = {
        'path': opts['path'],
        'method': opts['method'],
        'status': opts['status'],
        'rangeStart': rangeStart,
        'rangeEnd': rangeEnd,
        'pageSize': opts['pageSize'],
        'skip': opts['skip'],
        'sort': opts['sort']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = InlineResponse20010;
      return this.apiClient.callApi(
        '/v1/applications/{applicationId}/access_logs/no_total', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get access logs for application
     * @param {Number} applicationId 
     * @param {Date} rangeStart Only return results from after this timestamp, must be an RFC3339 timestamp string
     * @param {Date} rangeEnd Only return results from before this timestamp, must be an RFC3339 timestamp string
     * @param {Object} opts Optional parameters
     * @param {String} opts.path Only return results where the request path matches the given regular expression.
     * @param {module:model/String} opts.method Only return results where the request method matches the given regular expression.
     * @param {module:model/String} opts.status Filter results by HTTP status codes.
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @param {String} opts.sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/InlineResponse20010}
     */
    getAccessLogsWithoutTotalCount(applicationId, rangeStart, rangeEnd, opts) {
      return this.getAccessLogsWithoutTotalCountWithHttpInfo(applicationId, rangeStart, rangeEnd, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get Account Details
     * Return the details of your companies Talon.One account. 
     * @param {Number} accountId 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/Account} and HTTP response
     */
    getAccountWithHttpInfo(accountId) {
      let postBody = null;
      // verify the required parameter 'accountId' is set
      if (accountId === undefined || accountId === null) {
        throw new Error("Missing the required parameter 'accountId' when calling getAccount");
      }

      let pathParams = {
        'accountId': accountId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = Account;
      return this.apiClient.callApi(
        '/v1/accounts/{accountId}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get Account Details
     * Return the details of your companies Talon.One account. 
     * @param {Number} accountId 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/Account}
     */
    getAccount(accountId) {
      return this.getAccountWithHttpInfo(accountId)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get Account Analytics
     * Return the analytics of your companies Talon.One account. 
     * @param {Number} accountId 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/AccountAnalytics} and HTTP response
     */
    getAccountAnalyticsWithHttpInfo(accountId) {
      let postBody = null;
      // verify the required parameter 'accountId' is set
      if (accountId === undefined || accountId === null) {
        throw new Error("Missing the required parameter 'accountId' when calling getAccountAnalytics");
      }

      let pathParams = {
        'accountId': accountId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = AccountAnalytics;
      return this.apiClient.callApi(
        '/v1/accounts/{accountId}/analytics', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get Account Analytics
     * Return the analytics of your companies Talon.One account. 
     * @param {Number} accountId 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/AccountAnalytics}
     */
    getAccountAnalytics(accountId) {
      return this.getAccountAnalyticsWithHttpInfo(accountId)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get an additional cost
     * Returns additional cost for the account by its id. 
     * @param {Number} additionalCostId 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/AccountAdditionalCost} and HTTP response
     */
    getAdditionalCostWithHttpInfo(additionalCostId) {
      let postBody = null;
      // verify the required parameter 'additionalCostId' is set
      if (additionalCostId === undefined || additionalCostId === null) {
        throw new Error("Missing the required parameter 'additionalCostId' when calling getAdditionalCost");
      }

      let pathParams = {
        'additionalCostId': additionalCostId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = AccountAdditionalCost;
      return this.apiClient.callApi(
        '/v1/additional_costs/{additionalCostId}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get an additional cost
     * Returns additional cost for the account by its id. 
     * @param {Number} additionalCostId 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/AccountAdditionalCost}
     */
    getAdditionalCost(additionalCostId) {
      return this.getAdditionalCostWithHttpInfo(additionalCostId)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * List additional costs
     * Returns all the defined additional costs for the account. 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @param {String} opts.sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/InlineResponse20021} and HTTP response
     */
    getAdditionalCostsWithHttpInfo(opts) {
      opts = opts || {};
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
        'pageSize': opts['pageSize'],
        'skip': opts['skip'],
        'sort': opts['sort']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = InlineResponse20021;
      return this.apiClient.callApi(
        '/v1/additional_costs', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * List additional costs
     * Returns all the defined additional costs for the account. 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @param {String} opts.sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/InlineResponse20021}
     */
    getAdditionalCosts(opts) {
      return this.getAdditionalCostsWithHttpInfo(opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get all access logs
     * Fetches the access logs for the entire account. Sensitive requests (logins) are _always_ filtered from the logs. 
     * @param {Date} rangeStart Only return results from after this timestamp, must be an RFC3339 timestamp string
     * @param {Date} rangeEnd Only return results from before this timestamp, must be an RFC3339 timestamp string
     * @param {Object} opts Optional parameters
     * @param {String} opts.path Only return results where the request path matches the given regular expression.
     * @param {module:model/String} opts.method Only return results where the request method matches the given regular expression.
     * @param {module:model/String} opts.status Filter results by HTTP status codes.
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @param {String} opts.sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/InlineResponse2009} and HTTP response
     */
    getAllAccessLogsWithHttpInfo(rangeStart, rangeEnd, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'rangeStart' is set
      if (rangeStart === undefined || rangeStart === null) {
        throw new Error("Missing the required parameter 'rangeStart' when calling getAllAccessLogs");
      }
      // verify the required parameter 'rangeEnd' is set
      if (rangeEnd === undefined || rangeEnd === null) {
        throw new Error("Missing the required parameter 'rangeEnd' when calling getAllAccessLogs");
      }

      let pathParams = {
      };
      let queryParams = {
        'rangeStart': rangeStart,
        'rangeEnd': rangeEnd,
        'path': opts['path'],
        'method': opts['method'],
        'status': opts['status'],
        'pageSize': opts['pageSize'],
        'skip': opts['skip'],
        'sort': opts['sort']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = InlineResponse2009;
      return this.apiClient.callApi(
        '/v1/access_logs', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get all access logs
     * Fetches the access logs for the entire account. Sensitive requests (logins) are _always_ filtered from the logs. 
     * @param {Date} rangeStart Only return results from after this timestamp, must be an RFC3339 timestamp string
     * @param {Date} rangeEnd Only return results from before this timestamp, must be an RFC3339 timestamp string
     * @param {Object} opts Optional parameters
     * @param {String} opts.path Only return results where the request path matches the given regular expression.
     * @param {module:model/String} opts.method Only return results where the request method matches the given regular expression.
     * @param {module:model/String} opts.status Filter results by HTTP status codes.
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @param {String} opts.sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/InlineResponse2009}
     */
    getAllAccessLogs(rangeStart, rangeEnd, opts) {
      return this.getAllAccessLogsWithHttpInfo(rangeStart, rangeEnd, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get all roles.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/InlineResponse20030} and HTTP response
     */
    getAllRolesWithHttpInfo() {
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = InlineResponse20030;
      return this.apiClient.callApi(
        '/v1/roles', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get all roles.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/InlineResponse20030}
     */
    getAllRoles() {
      return this.getAllRolesWithHttpInfo()
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get Application
     * Get the application specified by the ID.
     * @param {Number} applicationId 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/Application} and HTTP response
     */
    getApplicationWithHttpInfo(applicationId) {
      let postBody = null;
      // verify the required parameter 'applicationId' is set
      if (applicationId === undefined || applicationId === null) {
        throw new Error("Missing the required parameter 'applicationId' when calling getApplication");
      }

      let pathParams = {
        'applicationId': applicationId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = Application;
      return this.apiClient.callApi(
        '/v1/applications/{applicationId}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get Application
     * Get the application specified by the ID.
     * @param {Number} applicationId 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/Application}
     */
    getApplication(applicationId) {
      return this.getApplicationWithHttpInfo(applicationId)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get report of health of application API
     * @param {Number} applicationId 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/ApplicationApiHealth} and HTTP response
     */
    getApplicationApiHealthWithHttpInfo(applicationId) {
      let postBody = null;
      // verify the required parameter 'applicationId' is set
      if (applicationId === undefined || applicationId === null) {
        throw new Error("Missing the required parameter 'applicationId' when calling getApplicationApiHealth");
      }

      let pathParams = {
        'applicationId': applicationId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = ApplicationApiHealth;
      return this.apiClient.callApi(
        '/v1/applications/{applicationId}/health_report', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get report of health of application API
     * @param {Number} applicationId 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/ApplicationApiHealth}
     */
    getApplicationApiHealth(applicationId) {
      return this.getApplicationApiHealthWithHttpInfo(applicationId)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get Application Customer
     * @param {Number} applicationId 
     * @param {Number} customerId 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/ApplicationCustomer} and HTTP response
     */
    getApplicationCustomerWithHttpInfo(applicationId, customerId) {
      let postBody = null;
      // verify the required parameter 'applicationId' is set
      if (applicationId === undefined || applicationId === null) {
        throw new Error("Missing the required parameter 'applicationId' when calling getApplicationCustomer");
      }
      // verify the required parameter 'customerId' is set
      if (customerId === undefined || customerId === null) {
        throw new Error("Missing the required parameter 'customerId' when calling getApplicationCustomer");
      }

      let pathParams = {
        'applicationId': applicationId,
        'customerId': customerId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = ApplicationCustomer;
      return this.apiClient.callApi(
        '/v1/applications/{applicationId}/customers/{customerId}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get Application Customer
     * @param {Number} applicationId 
     * @param {Number} customerId 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/ApplicationCustomer}
     */
    getApplicationCustomer(applicationId, customerId) {
      return this.getApplicationCustomerWithHttpInfo(applicationId, customerId)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * List Application Customers
     * @param {Number} applicationId 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/InlineResponse20012} and HTTP response
     */
    getApplicationCustomersWithHttpInfo(applicationId) {
      let postBody = null;
      // verify the required parameter 'applicationId' is set
      if (applicationId === undefined || applicationId === null) {
        throw new Error("Missing the required parameter 'applicationId' when calling getApplicationCustomers");
      }

      let pathParams = {
        'applicationId': applicationId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = InlineResponse20012;
      return this.apiClient.callApi(
        '/v1/applications/{applicationId}/customers', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * List Application Customers
     * @param {Number} applicationId 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/InlineResponse20012}
     */
    getApplicationCustomers(applicationId) {
      return this.getApplicationCustomersWithHttpInfo(applicationId)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get a list of the customer profiles that match the given attributes
     * Gets a list of all the customer profiles for the account that exactly match a set of attributes.  The match is successful if all the attributes of the request are found in a profile, even if the profile has more attributes that are not present on the request.  [Customer Profile]: https://help.talon.one/hc/en-us/articles/360005130739-Data-Model#CustomerProfile 
     * @param {module:model/ApplicationCustomerSearch} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/InlineResponse20013} and HTTP response
     */
    getApplicationCustomersByAttributesWithHttpInfo(body) {
      let postBody = body;
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling getApplicationCustomersByAttributes");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['integration_auth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = InlineResponse20013;
      return this.apiClient.callApi(
        '/v1/application_customer_search', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get a list of the customer profiles that match the given attributes
     * Gets a list of all the customer profiles for the account that exactly match a set of attributes.  The match is successful if all the attributes of the request are found in a profile, even if the profile has more attributes that are not present on the request.  [Customer Profile]: https://help.talon.one/hc/en-us/articles/360005130739-Data-Model#CustomerProfile 
     * @param {module:model/ApplicationCustomerSearch} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/InlineResponse20013}
     */
    getApplicationCustomersByAttributes(body) {
      return this.getApplicationCustomersByAttributesWithHttpInfo(body)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * List Applications Event Types
     * Get all of the distinct values of the Event `type` property for events recorded in the application.  See also: [Track an event](/integration-api/reference/#trackEvent) 
     * @param {Number} applicationId 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @param {String} opts.sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/InlineResponse20019} and HTTP response
     */
    getApplicationEventTypesWithHttpInfo(applicationId, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'applicationId' is set
      if (applicationId === undefined || applicationId === null) {
        throw new Error("Missing the required parameter 'applicationId' when calling getApplicationEventTypes");
      }

      let pathParams = {
        'applicationId': applicationId
      };
      let queryParams = {
        'pageSize': opts['pageSize'],
        'skip': opts['skip'],
        'sort': opts['sort']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = InlineResponse20019;
      return this.apiClient.callApi(
        '/v1/applications/{applicationId}/event_types', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * List Applications Event Types
     * Get all of the distinct values of the Event `type` property for events recorded in the application.  See also: [Track an event](/integration-api/reference/#trackEvent) 
     * @param {Number} applicationId 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @param {String} opts.sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/InlineResponse20019}
     */
    getApplicationEventTypes(applicationId, opts) {
      return this.getApplicationEventTypesWithHttpInfo(applicationId, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * List Applications Events
     * Lists all events recorded for an application. 
     * @param {Number} applicationId 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @param {String} opts.sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
     * @param {String} opts.type Comma-separated list of types by which to filter events. Must be exact match(es).
     * @param {Date} opts.createdBefore Only return events created before this date
     * @param {Date} opts.createdAfter Only return events created after this date
     * @param {String} opts.session Session integration ID filter for events. Must be exact match.
     * @param {String} opts.profile Profile integration ID filter for events. Must be exact match.
     * @param {String} opts.customerName Customer name filter for events. Will match substrings case-insensitively.
     * @param {String} opts.customerEmail Customer e-mail address filter for events. Will match substrings case-insensitively.
     * @param {String} opts.couponCode Coupon code
     * @param {String} opts.referralCode Referral code
     * @param {String} opts.ruleQuery Rule name filter for events
     * @param {String} opts.campaignQuery Campaign name filter for events
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/InlineResponse20017} and HTTP response
     */
    getApplicationEventsWithHttpInfo(applicationId, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'applicationId' is set
      if (applicationId === undefined || applicationId === null) {
        throw new Error("Missing the required parameter 'applicationId' when calling getApplicationEvents");
      }

      let pathParams = {
        'applicationId': applicationId
      };
      let queryParams = {
        'pageSize': opts['pageSize'],
        'skip': opts['skip'],
        'sort': opts['sort'],
        'type': opts['type'],
        'createdBefore': opts['createdBefore'],
        'createdAfter': opts['createdAfter'],
        'session': opts['session'],
        'profile': opts['profile'],
        'customerName': opts['customerName'],
        'customerEmail': opts['customerEmail'],
        'couponCode': opts['couponCode'],
        'referralCode': opts['referralCode'],
        'ruleQuery': opts['ruleQuery'],
        'campaignQuery': opts['campaignQuery']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = InlineResponse20017;
      return this.apiClient.callApi(
        '/v1/applications/{applicationId}/events', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * List Applications Events
     * Lists all events recorded for an application. 
     * @param {Number} applicationId 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @param {String} opts.sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
     * @param {String} opts.type Comma-separated list of types by which to filter events. Must be exact match(es).
     * @param {Date} opts.createdBefore Only return events created before this date
     * @param {Date} opts.createdAfter Only return events created after this date
     * @param {String} opts.session Session integration ID filter for events. Must be exact match.
     * @param {String} opts.profile Profile integration ID filter for events. Must be exact match.
     * @param {String} opts.customerName Customer name filter for events. Will match substrings case-insensitively.
     * @param {String} opts.customerEmail Customer e-mail address filter for events. Will match substrings case-insensitively.
     * @param {String} opts.couponCode Coupon code
     * @param {String} opts.referralCode Referral code
     * @param {String} opts.ruleQuery Rule name filter for events
     * @param {String} opts.campaignQuery Campaign name filter for events
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/InlineResponse20017}
     */
    getApplicationEvents(applicationId, opts) {
      return this.getApplicationEventsWithHttpInfo(applicationId, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * List Applications Events
     * Lists all events recorded for an application. Instead of having the total number of results in the response, this endpoint only if there are more results. 
     * @param {Number} applicationId 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @param {String} opts.sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
     * @param {String} opts.type Comma-separated list of types by which to filter events. Must be exact match(es).
     * @param {Date} opts.createdBefore Only return events created before this date
     * @param {Date} opts.createdAfter Only return events created after this date
     * @param {String} opts.session Session integration ID filter for events. Must be exact match.
     * @param {String} opts.profile Profile integration ID filter for events. Must be exact match.
     * @param {String} opts.customerName Customer name filter for events. Will match substrings case-insensitively.
     * @param {String} opts.customerEmail Customer e-mail address filter for events. Will match substrings case-insensitively.
     * @param {String} opts.couponCode Coupon code
     * @param {String} opts.referralCode Referral code
     * @param {String} opts.ruleQuery Rule name filter for events
     * @param {String} opts.campaignQuery Campaign name filter for events
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/InlineResponse20018} and HTTP response
     */
    getApplicationEventsWithoutTotalCountWithHttpInfo(applicationId, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'applicationId' is set
      if (applicationId === undefined || applicationId === null) {
        throw new Error("Missing the required parameter 'applicationId' when calling getApplicationEventsWithoutTotalCount");
      }

      let pathParams = {
        'applicationId': applicationId
      };
      let queryParams = {
        'pageSize': opts['pageSize'],
        'skip': opts['skip'],
        'sort': opts['sort'],
        'type': opts['type'],
        'createdBefore': opts['createdBefore'],
        'createdAfter': opts['createdAfter'],
        'session': opts['session'],
        'profile': opts['profile'],
        'customerName': opts['customerName'],
        'customerEmail': opts['customerEmail'],
        'couponCode': opts['couponCode'],
        'referralCode': opts['referralCode'],
        'ruleQuery': opts['ruleQuery'],
        'campaignQuery': opts['campaignQuery']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = InlineResponse20018;
      return this.apiClient.callApi(
        '/v1/applications/{applicationId}/events/no_total', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * List Applications Events
     * Lists all events recorded for an application. Instead of having the total number of results in the response, this endpoint only if there are more results. 
     * @param {Number} applicationId 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @param {String} opts.sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
     * @param {String} opts.type Comma-separated list of types by which to filter events. Must be exact match(es).
     * @param {Date} opts.createdBefore Only return events created before this date
     * @param {Date} opts.createdAfter Only return events created after this date
     * @param {String} opts.session Session integration ID filter for events. Must be exact match.
     * @param {String} opts.profile Profile integration ID filter for events. Must be exact match.
     * @param {String} opts.customerName Customer name filter for events. Will match substrings case-insensitively.
     * @param {String} opts.customerEmail Customer e-mail address filter for events. Will match substrings case-insensitively.
     * @param {String} opts.couponCode Coupon code
     * @param {String} opts.referralCode Referral code
     * @param {String} opts.ruleQuery Rule name filter for events
     * @param {String} opts.campaignQuery Campaign name filter for events
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/InlineResponse20018}
     */
    getApplicationEventsWithoutTotalCount(applicationId, opts) {
      return this.getApplicationEventsWithoutTotalCountWithHttpInfo(applicationId, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get Application Session
     * @param {Number} applicationId 
     * @param {Number} sessionId 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/ApplicationSession} and HTTP response
     */
    getApplicationSessionWithHttpInfo(applicationId, sessionId) {
      let postBody = null;
      // verify the required parameter 'applicationId' is set
      if (applicationId === undefined || applicationId === null) {
        throw new Error("Missing the required parameter 'applicationId' when calling getApplicationSession");
      }
      // verify the required parameter 'sessionId' is set
      if (sessionId === undefined || sessionId === null) {
        throw new Error("Missing the required parameter 'sessionId' when calling getApplicationSession");
      }

      let pathParams = {
        'applicationId': applicationId,
        'sessionId': sessionId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = ApplicationSession;
      return this.apiClient.callApi(
        '/v1/applications/{applicationId}/sessions/{sessionId}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get Application Session
     * @param {Number} applicationId 
     * @param {Number} sessionId 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/ApplicationSession}
     */
    getApplicationSession(applicationId, sessionId) {
      return this.getApplicationSessionWithHttpInfo(applicationId, sessionId)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * List Application Sessions
     * @param {Number} applicationId 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @param {String} opts.sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
     * @param {String} opts.profile Profile integration ID filter for sessions. Must be exact match.
     * @param {module:model/String} opts.state Filter by sessions with this state. Must be exact match.
     * @param {String} opts.coupon Filter by sessions with this coupon. Must be exact match.
     * @param {String} opts.referral Filter by sessions with this referral. Must be exact match.
     * @param {String} opts.integrationId Filter by sessions with this integrationId. Must be exact match.
     * @param {String} opts.customerId Filter by integration ID of the customer for the session
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/InlineResponse20016} and HTTP response
     */
    getApplicationSessionsWithHttpInfo(applicationId, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'applicationId' is set
      if (applicationId === undefined || applicationId === null) {
        throw new Error("Missing the required parameter 'applicationId' when calling getApplicationSessions");
      }

      let pathParams = {
        'applicationId': applicationId
      };
      let queryParams = {
        'pageSize': opts['pageSize'],
        'skip': opts['skip'],
        'sort': opts['sort'],
        'profile': opts['profile'],
        'state': opts['state'],
        'coupon': opts['coupon'],
        'referral': opts['referral'],
        'integrationId': opts['integrationId'],
        'customerId': opts['customerId']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = InlineResponse20016;
      return this.apiClient.callApi(
        '/v1/applications/{applicationId}/sessions', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * List Application Sessions
     * @param {Number} applicationId 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @param {String} opts.sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
     * @param {String} opts.profile Profile integration ID filter for sessions. Must be exact match.
     * @param {module:model/String} opts.state Filter by sessions with this state. Must be exact match.
     * @param {String} opts.coupon Filter by sessions with this coupon. Must be exact match.
     * @param {String} opts.referral Filter by sessions with this referral. Must be exact match.
     * @param {String} opts.integrationId Filter by sessions with this integrationId. Must be exact match.
     * @param {String} opts.customerId Filter by integration ID of the customer for the session
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/InlineResponse20016}
     */
    getApplicationSessions(applicationId, opts) {
      return this.getApplicationSessionsWithHttpInfo(applicationId, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * List Applications
     * List all application in the current account.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @param {String} opts.sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/InlineResponse2002} and HTTP response
     */
    getApplicationsWithHttpInfo(opts) {
      opts = opts || {};
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
        'pageSize': opts['pageSize'],
        'skip': opts['skip'],
        'sort': opts['sort']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = InlineResponse2002;
      return this.apiClient.callApi(
        '/v1/applications', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * List Applications
     * List all application in the current account.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @param {String} opts.sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/InlineResponse2002}
     */
    getApplications(opts) {
      return this.getApplicationsWithHttpInfo(opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get a custom attribute
     * Returns custom attribute for the account by its id. 
     * @param {Number} attributeId 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/Attribute} and HTTP response
     */
    getAttributeWithHttpInfo(attributeId) {
      let postBody = null;
      // verify the required parameter 'attributeId' is set
      if (attributeId === undefined || attributeId === null) {
        throw new Error("Missing the required parameter 'attributeId' when calling getAttribute");
      }

      let pathParams = {
        'attributeId': attributeId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = Attribute;
      return this.apiClient.callApi(
        '/v1/attributes/{attributeId}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get a custom attribute
     * Returns custom attribute for the account by its id. 
     * @param {Number} attributeId 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/Attribute}
     */
    getAttribute(attributeId) {
      return this.getAttributeWithHttpInfo(attributeId)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * List custom attributes
     * Returns all the defined custom attributes for the account. 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @param {String} opts.sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/InlineResponse20020} and HTTP response
     */
    getAttributesWithHttpInfo(opts) {
      opts = opts || {};
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
        'pageSize': opts['pageSize'],
        'skip': opts['skip'],
        'sort': opts['sort']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = InlineResponse20020;
      return this.apiClient.callApi(
        '/v1/attributes', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * List custom attributes
     * Returns all the defined custom attributes for the account. 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @param {String} opts.sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/InlineResponse20020}
     */
    getAttributes(opts) {
      return this.getAttributesWithHttpInfo(opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get a Campaign
     * @param {Number} applicationId 
     * @param {Number} campaignId 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/Campaign} and HTTP response
     */
    getCampaignWithHttpInfo(applicationId, campaignId) {
      let postBody = null;
      // verify the required parameter 'applicationId' is set
      if (applicationId === undefined || applicationId === null) {
        throw new Error("Missing the required parameter 'applicationId' when calling getCampaign");
      }
      // verify the required parameter 'campaignId' is set
      if (campaignId === undefined || campaignId === null) {
        throw new Error("Missing the required parameter 'campaignId' when calling getCampaign");
      }

      let pathParams = {
        'applicationId': applicationId,
        'campaignId': campaignId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = Campaign;
      return this.apiClient.callApi(
        '/v1/applications/{applicationId}/campaigns/{campaignId}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get a Campaign
     * @param {Number} applicationId 
     * @param {Number} campaignId 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/Campaign}
     */
    getCampaign(applicationId, campaignId) {
      return this.getCampaignWithHttpInfo(applicationId, campaignId)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get analytics of campaigns
     * @param {Number} applicationId 
     * @param {Number} campaignId 
     * @param {Date} rangeStart Only return results from after this timestamp, must be an RFC3339 timestamp string
     * @param {Date} rangeEnd Only return results from before this timestamp, must be an RFC3339 timestamp string
     * @param {Object} opts Optional parameters
     * @param {module:model/String} opts.granularity The time interval between the results in the returned time-series.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/InlineResponse20011} and HTTP response
     */
    getCampaignAnalyticsWithHttpInfo(applicationId, campaignId, rangeStart, rangeEnd, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'applicationId' is set
      if (applicationId === undefined || applicationId === null) {
        throw new Error("Missing the required parameter 'applicationId' when calling getCampaignAnalytics");
      }
      // verify the required parameter 'campaignId' is set
      if (campaignId === undefined || campaignId === null) {
        throw new Error("Missing the required parameter 'campaignId' when calling getCampaignAnalytics");
      }
      // verify the required parameter 'rangeStart' is set
      if (rangeStart === undefined || rangeStart === null) {
        throw new Error("Missing the required parameter 'rangeStart' when calling getCampaignAnalytics");
      }
      // verify the required parameter 'rangeEnd' is set
      if (rangeEnd === undefined || rangeEnd === null) {
        throw new Error("Missing the required parameter 'rangeEnd' when calling getCampaignAnalytics");
      }

      let pathParams = {
        'applicationId': applicationId,
        'campaignId': campaignId
      };
      let queryParams = {
        'rangeStart': rangeStart,
        'rangeEnd': rangeEnd,
        'granularity': opts['granularity']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = InlineResponse20011;
      return this.apiClient.callApi(
        '/v1/applications/{applicationId}/campaigns/{campaignId}/analytics', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get analytics of campaigns
     * @param {Number} applicationId 
     * @param {Number} campaignId 
     * @param {Date} rangeStart Only return results from after this timestamp, must be an RFC3339 timestamp string
     * @param {Date} rangeEnd Only return results from before this timestamp, must be an RFC3339 timestamp string
     * @param {Object} opts Optional parameters
     * @param {module:model/String} opts.granularity The time interval between the results in the returned time-series.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/InlineResponse20011}
     */
    getCampaignAnalytics(applicationId, campaignId, rangeStart, rangeEnd, opts) {
      return this.getCampaignAnalyticsWithHttpInfo(applicationId, campaignId, rangeStart, rangeEnd, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get a list of all campaigns that match the given attributes
     * Gets a list of all the campaigns that exactly match a set of attributes. 
     * @param {Number} applicationId 
     * @param {module:model/CampaignSearch} body 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @param {String} opts.sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
     * @param {module:model/String} opts.campaignState Filter results by the state of the campaign.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/InlineResponse2003} and HTTP response
     */
    getCampaignByAttributesWithHttpInfo(applicationId, body, opts) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'applicationId' is set
      if (applicationId === undefined || applicationId === null) {
        throw new Error("Missing the required parameter 'applicationId' when calling getCampaignByAttributes");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling getCampaignByAttributes");
      }

      let pathParams = {
        'applicationId': applicationId
      };
      let queryParams = {
        'pageSize': opts['pageSize'],
        'skip': opts['skip'],
        'sort': opts['sort'],
        'campaignState': opts['campaignState']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = InlineResponse2003;
      return this.apiClient.callApi(
        '/v1/applications/{applicationId}/campaigns_search', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get a list of all campaigns that match the given attributes
     * Gets a list of all the campaigns that exactly match a set of attributes. 
     * @param {Number} applicationId 
     * @param {module:model/CampaignSearch} body 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @param {String} opts.sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
     * @param {module:model/String} opts.campaignState Filter results by the state of the campaign.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/InlineResponse2003}
     */
    getCampaignByAttributes(applicationId, body, opts) {
      return this.getCampaignByAttributesWithHttpInfo(applicationId, body, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * List CampaignSet
     * @param {Number} applicationId 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/CampaignSet} and HTTP response
     */
    getCampaignSetWithHttpInfo(applicationId) {
      let postBody = null;
      // verify the required parameter 'applicationId' is set
      if (applicationId === undefined || applicationId === null) {
        throw new Error("Missing the required parameter 'applicationId' when calling getCampaignSet");
      }

      let pathParams = {
        'applicationId': applicationId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = CampaignSet;
      return this.apiClient.callApi(
        '/v1/applications/{applicationId}/campaign_set', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * List CampaignSet
     * @param {Number} applicationId 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/CampaignSet}
     */
    getCampaignSet(applicationId) {
      return this.getCampaignSetWithHttpInfo(applicationId)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * List your Campaigns
     * @param {Number} applicationId 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @param {String} opts.sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
     * @param {module:model/String} opts.campaignState Filter results by the state of the campaign.
     * @param {String} opts.name Filter results performing case-insensitive matching against the name of the campaign.
     * @param {String} opts.tags Filter results performing case-insensitive matching against the tags of the campaign. When used in conjunction with the \"name\" query parameter, a logical OR will be performed to search both tags and name for the provided values 
     * @param {Date} opts.createdBefore Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the campaign creation timestamp.
     * @param {Date} opts.createdAfter Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the campaign creation timestamp.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/InlineResponse2003} and HTTP response
     */
    getCampaignsWithHttpInfo(applicationId, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'applicationId' is set
      if (applicationId === undefined || applicationId === null) {
        throw new Error("Missing the required parameter 'applicationId' when calling getCampaigns");
      }

      let pathParams = {
        'applicationId': applicationId
      };
      let queryParams = {
        'pageSize': opts['pageSize'],
        'skip': opts['skip'],
        'sort': opts['sort'],
        'campaignState': opts['campaignState'],
        'name': opts['name'],
        'tags': opts['tags'],
        'createdBefore': opts['createdBefore'],
        'createdAfter': opts['createdAfter']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = InlineResponse2003;
      return this.apiClient.callApi(
        '/v1/applications/{applicationId}/campaigns', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * List your Campaigns
     * @param {Number} applicationId 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @param {String} opts.sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
     * @param {module:model/String} opts.campaignState Filter results by the state of the campaign.
     * @param {String} opts.name Filter results performing case-insensitive matching against the name of the campaign.
     * @param {String} opts.tags Filter results performing case-insensitive matching against the tags of the campaign. When used in conjunction with the \"name\" query parameter, a logical OR will be performed to search both tags and name for the provided values 
     * @param {Date} opts.createdBefore Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the campaign creation timestamp.
     * @param {Date} opts.createdAfter Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the campaign creation timestamp.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/InlineResponse2003}
     */
    getCampaigns(applicationId, opts) {
      return this.getCampaignsWithHttpInfo(applicationId, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get audit log for an account
     * Get list of changes caused by API calls for an account. Only accessible for admins.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @param {String} opts.sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
     * @param {Number} opts.applicationId 
     * @param {Date} opts.createdBefore Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the change creation timestamp.
     * @param {Date} opts.createdAfter Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the change creation timestamp.
     * @param {Boolean} opts.withTotalResultSize When this flag is set, the result will include the total size of the result, across all pages. This might decrease performance on large data sets. With this flag set to true, hasMore will be be true whenever there is a next page. totalResultSize will always be zero. With this flag set to false, hasMore will always be set to false. totalResultSize will contain the total number of results for this query. 
     * @param {Boolean} opts.includeOld When this flag is set to false, the state without the change will not be returned. The default value is true.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/InlineResponse20027} and HTTP response
     */
    getChangesWithHttpInfo(opts) {
      opts = opts || {};
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
        'pageSize': opts['pageSize'],
        'skip': opts['skip'],
        'sort': opts['sort'],
        'applicationId': opts['applicationId'],
        'createdBefore': opts['createdBefore'],
        'createdAfter': opts['createdAfter'],
        'withTotalResultSize': opts['withTotalResultSize'],
        'includeOld': opts['includeOld']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = InlineResponse20027;
      return this.apiClient.callApi(
        '/v1/changes', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get audit log for an account
     * Get list of changes caused by API calls for an account. Only accessible for admins.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @param {String} opts.sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
     * @param {Number} opts.applicationId 
     * @param {Date} opts.createdBefore Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the change creation timestamp.
     * @param {Date} opts.createdAfter Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the change creation timestamp.
     * @param {Boolean} opts.withTotalResultSize When this flag is set, the result will include the total size of the result, across all pages. This might decrease performance on large data sets. With this flag set to true, hasMore will be be true whenever there is a next page. totalResultSize will always be zero. With this flag set to false, hasMore will always be set to false. totalResultSize will contain the total number of results for this query. 
     * @param {Boolean} opts.includeOld When this flag is set to false, the state without the change will not be returned. The default value is true.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/InlineResponse20027}
     */
    getChanges(opts) {
      return this.getChangesWithHttpInfo(opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * List Coupons
     * @param {Number} applicationId 
     * @param {Number} campaignId 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @param {String} opts.sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
     * @param {String} opts.value Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters.
     * @param {Date} opts.createdBefore Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
     * @param {Date} opts.createdAfter Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
     * @param {Date} opts.startsAfter Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
     * @param {Date} opts.startsBefore Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
     * @param {Date} opts.expiresAfter Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
     * @param {Date} opts.expiresBefore Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
     * @param {module:model/String} opts.valid Either \"expired\", \"validNow\", or \"validFuture\". The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. 
     * @param {String} opts.batchId Filter results by batches of coupons
     * @param {module:model/String} opts.usable Either \"true\" or \"false\". If \"true\", only coupons where `usageCounter < usageLimit` will be returned, \"false\" will return only coupons where `usageCounter >= usageLimit`. 
     * @param {Number} opts.referralId Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code.
     * @param {String} opts.recipientIntegrationId Filter results by match with a profile id specified in the coupon's RecipientIntegrationId field
     * @param {Boolean} opts.exactMatch Filter results to an exact case-insensitive matching against the coupon code (default to false)
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/InlineResponse2001} and HTTP response
     */
    getCouponsWithHttpInfo(applicationId, campaignId, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'applicationId' is set
      if (applicationId === undefined || applicationId === null) {
        throw new Error("Missing the required parameter 'applicationId' when calling getCoupons");
      }
      // verify the required parameter 'campaignId' is set
      if (campaignId === undefined || campaignId === null) {
        throw new Error("Missing the required parameter 'campaignId' when calling getCoupons");
      }

      let pathParams = {
        'applicationId': applicationId,
        'campaignId': campaignId
      };
      let queryParams = {
        'pageSize': opts['pageSize'],
        'skip': opts['skip'],
        'sort': opts['sort'],
        'value': opts['value'],
        'createdBefore': opts['createdBefore'],
        'createdAfter': opts['createdAfter'],
        'startsAfter': opts['startsAfter'],
        'startsBefore': opts['startsBefore'],
        'expiresAfter': opts['expiresAfter'],
        'expiresBefore': opts['expiresBefore'],
        'valid': opts['valid'],
        'batchId': opts['batchId'],
        'usable': opts['usable'],
        'referralId': opts['referralId'],
        'recipientIntegrationId': opts['recipientIntegrationId'],
        'exactMatch': opts['exactMatch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = InlineResponse2001;
      return this.apiClient.callApi(
        '/v1/applications/{applicationId}/campaigns/{campaignId}/coupons', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * List Coupons
     * @param {Number} applicationId 
     * @param {Number} campaignId 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @param {String} opts.sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
     * @param {String} opts.value Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters.
     * @param {Date} opts.createdBefore Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
     * @param {Date} opts.createdAfter Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
     * @param {Date} opts.startsAfter Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
     * @param {Date} opts.startsBefore Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
     * @param {Date} opts.expiresAfter Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
     * @param {Date} opts.expiresBefore Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
     * @param {module:model/String} opts.valid Either \"expired\", \"validNow\", or \"validFuture\". The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. 
     * @param {String} opts.batchId Filter results by batches of coupons
     * @param {module:model/String} opts.usable Either \"true\" or \"false\". If \"true\", only coupons where `usageCounter < usageLimit` will be returned, \"false\" will return only coupons where `usageCounter >= usageLimit`. 
     * @param {Number} opts.referralId Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code.
     * @param {String} opts.recipientIntegrationId Filter results by match with a profile id specified in the coupon's RecipientIntegrationId field
     * @param {Boolean} opts.exactMatch Filter results to an exact case-insensitive matching against the coupon code (default to false)
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/InlineResponse2001}
     */
    getCoupons(applicationId, campaignId, opts) {
      return this.getCouponsWithHttpInfo(applicationId, campaignId, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get a list of the coupons that match the given attributes
     * Gets a list of all the coupons that exactly match a set of attributes.  The match is successful if all the attributes of the request are found in a coupon, even if the coupon has more attributes that are not present on the request. 
     * @param {Number} applicationId 
     * @param {Number} campaignId 
     * @param {module:model/CouponSearch} body 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @param {String} opts.sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
     * @param {String} opts.value Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters.
     * @param {Date} opts.createdBefore Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
     * @param {Date} opts.createdAfter Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
     * @param {module:model/String} opts.valid Either \"expired\", \"validNow\", or \"validFuture\". The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. 
     * @param {module:model/String} opts.usable Either \"true\" or \"false\". If \"true\", only coupons where `usageCounter < usageLimit` will be returned, \"false\" will return only coupons where `usageCounter >= usageLimit`. 
     * @param {Number} opts.referralId Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code.
     * @param {String} opts.recipientIntegrationId Filter results by match with a profile id specified in the coupon's RecipientIntegrationId field
     * @param {Boolean} opts.exactMatch Filter results to an exact case-insensitive matching against the coupon code (default to false)
     * @param {String} opts.batchId Filter results by batches of coupons
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/InlineResponse2001} and HTTP response
     */
    getCouponsByAttributesWithHttpInfo(applicationId, campaignId, body, opts) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'applicationId' is set
      if (applicationId === undefined || applicationId === null) {
        throw new Error("Missing the required parameter 'applicationId' when calling getCouponsByAttributes");
      }
      // verify the required parameter 'campaignId' is set
      if (campaignId === undefined || campaignId === null) {
        throw new Error("Missing the required parameter 'campaignId' when calling getCouponsByAttributes");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling getCouponsByAttributes");
      }

      let pathParams = {
        'applicationId': applicationId,
        'campaignId': campaignId
      };
      let queryParams = {
        'pageSize': opts['pageSize'],
        'skip': opts['skip'],
        'sort': opts['sort'],
        'value': opts['value'],
        'createdBefore': opts['createdBefore'],
        'createdAfter': opts['createdAfter'],
        'valid': opts['valid'],
        'usable': opts['usable'],
        'referralId': opts['referralId'],
        'recipientIntegrationId': opts['recipientIntegrationId'],
        'exactMatch': opts['exactMatch'],
        'batchId': opts['batchId']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = InlineResponse2001;
      return this.apiClient.callApi(
        '/v1/applications/{applicationId}/campaigns/{campaignId}/coupons_search', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get a list of the coupons that match the given attributes
     * Gets a list of all the coupons that exactly match a set of attributes.  The match is successful if all the attributes of the request are found in a coupon, even if the coupon has more attributes that are not present on the request. 
     * @param {Number} applicationId 
     * @param {Number} campaignId 
     * @param {module:model/CouponSearch} body 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @param {String} opts.sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
     * @param {String} opts.value Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters.
     * @param {Date} opts.createdBefore Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
     * @param {Date} opts.createdAfter Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
     * @param {module:model/String} opts.valid Either \"expired\", \"validNow\", or \"validFuture\". The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. 
     * @param {module:model/String} opts.usable Either \"true\" or \"false\". If \"true\", only coupons where `usageCounter < usageLimit` will be returned, \"false\" will return only coupons where `usageCounter >= usageLimit`. 
     * @param {Number} opts.referralId Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code.
     * @param {String} opts.recipientIntegrationId Filter results by match with a profile id specified in the coupon's RecipientIntegrationId field
     * @param {Boolean} opts.exactMatch Filter results to an exact case-insensitive matching against the coupon code (default to false)
     * @param {String} opts.batchId Filter results by batches of coupons
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/InlineResponse2001}
     */
    getCouponsByAttributes(applicationId, campaignId, body, opts) {
      return this.getCouponsByAttributesWithHttpInfo(applicationId, campaignId, body, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get a list of the coupons that match the given attributes in all active campaigns of an application
     * Gets a list of all the coupons with attributes matching the query criteria Application wide 
     * @param {Number} applicationId 
     * @param {module:model/CouponSearch} body 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @param {String} opts.sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
     * @param {String} opts.value Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters.
     * @param {Date} opts.createdBefore Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
     * @param {Date} opts.createdAfter Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
     * @param {module:model/String} opts.valid Either \"expired\", \"validNow\", or \"validFuture\". The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. 
     * @param {module:model/String} opts.usable Either \"true\" or \"false\". If \"true\", only coupons where `usageCounter < usageLimit` will be returned, \"false\" will return only coupons where `usageCounter >= usageLimit`. 
     * @param {Number} opts.referralId Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code.
     * @param {String} opts.recipientIntegrationId Filter results by match with a profile id specified in the coupon's RecipientIntegrationId field
     * @param {String} opts.batchId Filter results by batches of coupons
     * @param {Boolean} opts.exactMatch Filter results to an exact case-insensitive matching against the coupon code (default to false)
     * @param {module:model/String} opts.campaignState Filter results by the state of the campaign.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/InlineResponse2001} and HTTP response
     */
    getCouponsByAttributesApplicationWideWithHttpInfo(applicationId, body, opts) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'applicationId' is set
      if (applicationId === undefined || applicationId === null) {
        throw new Error("Missing the required parameter 'applicationId' when calling getCouponsByAttributesApplicationWide");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling getCouponsByAttributesApplicationWide");
      }

      let pathParams = {
        'applicationId': applicationId
      };
      let queryParams = {
        'pageSize': opts['pageSize'],
        'skip': opts['skip'],
        'sort': opts['sort'],
        'value': opts['value'],
        'createdBefore': opts['createdBefore'],
        'createdAfter': opts['createdAfter'],
        'valid': opts['valid'],
        'usable': opts['usable'],
        'referralId': opts['referralId'],
        'recipientIntegrationId': opts['recipientIntegrationId'],
        'batchId': opts['batchId'],
        'exactMatch': opts['exactMatch'],
        'campaignState': opts['campaignState']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = InlineResponse2001;
      return this.apiClient.callApi(
        '/v1/applications/{applicationId}/coupons_search', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get a list of the coupons that match the given attributes in all active campaigns of an application
     * Gets a list of all the coupons with attributes matching the query criteria Application wide 
     * @param {Number} applicationId 
     * @param {module:model/CouponSearch} body 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @param {String} opts.sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
     * @param {String} opts.value Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters.
     * @param {Date} opts.createdBefore Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
     * @param {Date} opts.createdAfter Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
     * @param {module:model/String} opts.valid Either \"expired\", \"validNow\", or \"validFuture\". The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. 
     * @param {module:model/String} opts.usable Either \"true\" or \"false\". If \"true\", only coupons where `usageCounter < usageLimit` will be returned, \"false\" will return only coupons where `usageCounter >= usageLimit`. 
     * @param {Number} opts.referralId Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code.
     * @param {String} opts.recipientIntegrationId Filter results by match with a profile id specified in the coupon's RecipientIntegrationId field
     * @param {String} opts.batchId Filter results by batches of coupons
     * @param {Boolean} opts.exactMatch Filter results to an exact case-insensitive matching against the coupon code (default to false)
     * @param {module:model/String} opts.campaignState Filter results by the state of the campaign.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/InlineResponse2001}
     */
    getCouponsByAttributesApplicationWide(applicationId, body, opts) {
      return this.getCouponsByAttributesApplicationWideWithHttpInfo(applicationId, body, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * List Coupons
     * @param {Number} applicationId 
     * @param {Number} campaignId 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @param {String} opts.sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
     * @param {String} opts.value Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters.
     * @param {Date} opts.createdBefore Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
     * @param {Date} opts.createdAfter Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
     * @param {module:model/String} opts.valid Either \"expired\", \"validNow\", or \"validFuture\". The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. 
     * @param {module:model/String} opts.usable Either \"true\" or \"false\". If \"true\", only coupons where `usageCounter < usageLimit` will be returned, \"false\" will return only coupons where `usageCounter >= usageLimit`. 
     * @param {Number} opts.referralId Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code.
     * @param {String} opts.recipientIntegrationId Filter results by match with a profile id specified in the coupon's RecipientIntegrationId field
     * @param {String} opts.batchId Filter results by batches of coupons
     * @param {Boolean} opts.exactMatch Filter results to an exact case-insensitive matching against the coupon code (default to false)
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/InlineResponse2005} and HTTP response
     */
    getCouponsWithoutTotalCountWithHttpInfo(applicationId, campaignId, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'applicationId' is set
      if (applicationId === undefined || applicationId === null) {
        throw new Error("Missing the required parameter 'applicationId' when calling getCouponsWithoutTotalCount");
      }
      // verify the required parameter 'campaignId' is set
      if (campaignId === undefined || campaignId === null) {
        throw new Error("Missing the required parameter 'campaignId' when calling getCouponsWithoutTotalCount");
      }

      let pathParams = {
        'applicationId': applicationId,
        'campaignId': campaignId
      };
      let queryParams = {
        'pageSize': opts['pageSize'],
        'skip': opts['skip'],
        'sort': opts['sort'],
        'value': opts['value'],
        'createdBefore': opts['createdBefore'],
        'createdAfter': opts['createdAfter'],
        'valid': opts['valid'],
        'usable': opts['usable'],
        'referralId': opts['referralId'],
        'recipientIntegrationId': opts['recipientIntegrationId'],
        'batchId': opts['batchId'],
        'exactMatch': opts['exactMatch']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = InlineResponse2005;
      return this.apiClient.callApi(
        '/v1/applications/{applicationId}/campaigns/{campaignId}/coupons/no_total', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * List Coupons
     * @param {Number} applicationId 
     * @param {Number} campaignId 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @param {String} opts.sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
     * @param {String} opts.value Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters.
     * @param {Date} opts.createdBefore Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
     * @param {Date} opts.createdAfter Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
     * @param {module:model/String} opts.valid Either \"expired\", \"validNow\", or \"validFuture\". The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. 
     * @param {module:model/String} opts.usable Either \"true\" or \"false\". If \"true\", only coupons where `usageCounter < usageLimit` will be returned, \"false\" will return only coupons where `usageCounter >= usageLimit`. 
     * @param {Number} opts.referralId Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code.
     * @param {String} opts.recipientIntegrationId Filter results by match with a profile id specified in the coupon's RecipientIntegrationId field
     * @param {String} opts.batchId Filter results by batches of coupons
     * @param {Boolean} opts.exactMatch Filter results to an exact case-insensitive matching against the coupon code (default to false)
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/InlineResponse2005}
     */
    getCouponsWithoutTotalCount(applicationId, campaignId, opts) {
      return this.getCouponsWithoutTotalCountWithHttpInfo(applicationId, campaignId, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get Activity Report for Single Customer
     * Fetch summary report for single application customer based on a time range
     * @param {Date} rangeStart Only return results from after this timestamp, must be an RFC3339 timestamp string
     * @param {Date} rangeEnd Only return results from before this timestamp, must be an RFC3339 timestamp string
     * @param {Number} applicationId 
     * @param {Number} customerId 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/CustomerActivityReport} and HTTP response
     */
    getCustomerActivityReportWithHttpInfo(rangeStart, rangeEnd, applicationId, customerId, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'rangeStart' is set
      if (rangeStart === undefined || rangeStart === null) {
        throw new Error("Missing the required parameter 'rangeStart' when calling getCustomerActivityReport");
      }
      // verify the required parameter 'rangeEnd' is set
      if (rangeEnd === undefined || rangeEnd === null) {
        throw new Error("Missing the required parameter 'rangeEnd' when calling getCustomerActivityReport");
      }
      // verify the required parameter 'applicationId' is set
      if (applicationId === undefined || applicationId === null) {
        throw new Error("Missing the required parameter 'applicationId' when calling getCustomerActivityReport");
      }
      // verify the required parameter 'customerId' is set
      if (customerId === undefined || customerId === null) {
        throw new Error("Missing the required parameter 'customerId' when calling getCustomerActivityReport");
      }

      let pathParams = {
        'applicationId': applicationId,
        'customerId': customerId
      };
      let queryParams = {
        'pageSize': opts['pageSize'],
        'skip': opts['skip'],
        'rangeStart': rangeStart,
        'rangeEnd': rangeEnd
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = CustomerActivityReport;
      return this.apiClient.callApi(
        '/v1/applications/{applicationId}/customer_activity_reports/{customerId}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get Activity Report for Single Customer
     * Fetch summary report for single application customer based on a time range
     * @param {Date} rangeStart Only return results from after this timestamp, must be an RFC3339 timestamp string
     * @param {Date} rangeEnd Only return results from before this timestamp, must be an RFC3339 timestamp string
     * @param {Number} applicationId 
     * @param {Number} customerId 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/CustomerActivityReport}
     */
    getCustomerActivityReport(rangeStart, rangeEnd, applicationId, customerId, opts) {
      return this.getCustomerActivityReportWithHttpInfo(rangeStart, rangeEnd, applicationId, customerId, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get Activity Reports for Application Customers
     * Fetch summary reports for all application customers based on a time range
     * @param {Date} rangeStart Only return results from after this timestamp, must be an RFC3339 timestamp string
     * @param {Date} rangeEnd Only return results from before this timestamp, must be an RFC3339 timestamp string
     * @param {Number} applicationId 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @param {String} opts.sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
     * @param {String} opts.name Only return reports matching the customer name
     * @param {String} opts.integrationId Only return reports matching the integrationId
     * @param {String} opts.campaignName Only return reports matching the campaignName
     * @param {String} opts.advocateName Only return reports matching the current customer referrer name
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/InlineResponse20014} and HTTP response
     */
    getCustomerActivityReportsWithHttpInfo(rangeStart, rangeEnd, applicationId, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'rangeStart' is set
      if (rangeStart === undefined || rangeStart === null) {
        throw new Error("Missing the required parameter 'rangeStart' when calling getCustomerActivityReports");
      }
      // verify the required parameter 'rangeEnd' is set
      if (rangeEnd === undefined || rangeEnd === null) {
        throw new Error("Missing the required parameter 'rangeEnd' when calling getCustomerActivityReports");
      }
      // verify the required parameter 'applicationId' is set
      if (applicationId === undefined || applicationId === null) {
        throw new Error("Missing the required parameter 'applicationId' when calling getCustomerActivityReports");
      }

      let pathParams = {
        'applicationId': applicationId
      };
      let queryParams = {
        'pageSize': opts['pageSize'],
        'skip': opts['skip'],
        'sort': opts['sort'],
        'rangeStart': rangeStart,
        'rangeEnd': rangeEnd,
        'name': opts['name'],
        'integrationId': opts['integrationId'],
        'campaignName': opts['campaignName'],
        'advocateName': opts['advocateName']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = InlineResponse20014;
      return this.apiClient.callApi(
        '/v1/applications/{applicationId}/customer_activity_reports', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get Activity Reports for Application Customers
     * Fetch summary reports for all application customers based on a time range
     * @param {Date} rangeStart Only return results from after this timestamp, must be an RFC3339 timestamp string
     * @param {Date} rangeEnd Only return results from before this timestamp, must be an RFC3339 timestamp string
     * @param {Number} applicationId 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @param {String} opts.sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
     * @param {String} opts.name Only return reports matching the customer name
     * @param {String} opts.integrationId Only return reports matching the integrationId
     * @param {String} opts.campaignName Only return reports matching the campaignName
     * @param {String} opts.advocateName Only return reports matching the current customer referrer name
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/InlineResponse20014}
     */
    getCustomerActivityReports(rangeStart, rangeEnd, applicationId, opts) {
      return this.getCustomerActivityReportsWithHttpInfo(rangeStart, rangeEnd, applicationId, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get Activity Reports for Application Customers
     * Fetch summary reports for all application customers based on a time range. Instead of having the total number of results in the response, this endpoint only if there are more results.
     * @param {Date} rangeStart Only return results from after this timestamp, must be an RFC3339 timestamp string
     * @param {Date} rangeEnd Only return results from before this timestamp, must be an RFC3339 timestamp string
     * @param {Number} applicationId 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @param {String} opts.sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
     * @param {String} opts.name Only return reports matching the customer name
     * @param {String} opts.integrationId Only return reports matching the integrationId
     * @param {String} opts.campaignName Only return reports matching the campaignName
     * @param {String} opts.advocateName Only return reports matching the current customer referrer name
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/InlineResponse20015} and HTTP response
     */
    getCustomerActivityReportsWithoutTotalCountWithHttpInfo(rangeStart, rangeEnd, applicationId, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'rangeStart' is set
      if (rangeStart === undefined || rangeStart === null) {
        throw new Error("Missing the required parameter 'rangeStart' when calling getCustomerActivityReportsWithoutTotalCount");
      }
      // verify the required parameter 'rangeEnd' is set
      if (rangeEnd === undefined || rangeEnd === null) {
        throw new Error("Missing the required parameter 'rangeEnd' when calling getCustomerActivityReportsWithoutTotalCount");
      }
      // verify the required parameter 'applicationId' is set
      if (applicationId === undefined || applicationId === null) {
        throw new Error("Missing the required parameter 'applicationId' when calling getCustomerActivityReportsWithoutTotalCount");
      }

      let pathParams = {
        'applicationId': applicationId
      };
      let queryParams = {
        'pageSize': opts['pageSize'],
        'skip': opts['skip'],
        'sort': opts['sort'],
        'rangeStart': rangeStart,
        'rangeEnd': rangeEnd,
        'name': opts['name'],
        'integrationId': opts['integrationId'],
        'campaignName': opts['campaignName'],
        'advocateName': opts['advocateName']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = InlineResponse20015;
      return this.apiClient.callApi(
        '/v1/applications/{applicationId}/customer_activity_reports/no_total', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get Activity Reports for Application Customers
     * Fetch summary reports for all application customers based on a time range. Instead of having the total number of results in the response, this endpoint only if there are more results.
     * @param {Date} rangeStart Only return results from after this timestamp, must be an RFC3339 timestamp string
     * @param {Date} rangeEnd Only return results from before this timestamp, must be an RFC3339 timestamp string
     * @param {Number} applicationId 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @param {String} opts.sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
     * @param {String} opts.name Only return reports matching the customer name
     * @param {String} opts.integrationId Only return reports matching the integrationId
     * @param {String} opts.campaignName Only return reports matching the campaignName
     * @param {String} opts.advocateName Only return reports matching the current customer referrer name
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/InlineResponse20015}
     */
    getCustomerActivityReportsWithoutTotalCount(rangeStart, rangeEnd, applicationId, opts) {
      return this.getCustomerActivityReportsWithoutTotalCountWithHttpInfo(rangeStart, rangeEnd, applicationId, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get Analytics Report for a Customer
     * Fetch analytics for single application customer
     * @param {Number} applicationId 
     * @param {Number} customerId 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @param {String} opts.sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/CustomerAnalytics} and HTTP response
     */
    getCustomerAnalyticsWithHttpInfo(applicationId, customerId, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'applicationId' is set
      if (applicationId === undefined || applicationId === null) {
        throw new Error("Missing the required parameter 'applicationId' when calling getCustomerAnalytics");
      }
      // verify the required parameter 'customerId' is set
      if (customerId === undefined || customerId === null) {
        throw new Error("Missing the required parameter 'customerId' when calling getCustomerAnalytics");
      }

      let pathParams = {
        'applicationId': applicationId,
        'customerId': customerId
      };
      let queryParams = {
        'pageSize': opts['pageSize'],
        'skip': opts['skip'],
        'sort': opts['sort']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = CustomerAnalytics;
      return this.apiClient.callApi(
        '/v1/applications/{applicationId}/customers/{customerId}/analytics', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get Analytics Report for a Customer
     * Fetch analytics for single application customer
     * @param {Number} applicationId 
     * @param {Number} customerId 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @param {String} opts.sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/CustomerAnalytics}
     */
    getCustomerAnalytics(applicationId, customerId, opts) {
      return this.getCustomerAnalyticsWithHttpInfo(applicationId, customerId, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get Customer Profile
     * @param {Number} applicationId 
     * @param {Number} customerId 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/ApplicationCustomer} and HTTP response
     */
    getCustomerProfileWithHttpInfo(applicationId, customerId) {
      let postBody = null;
      // verify the required parameter 'applicationId' is set
      if (applicationId === undefined || applicationId === null) {
        throw new Error("Missing the required parameter 'applicationId' when calling getCustomerProfile");
      }
      // verify the required parameter 'customerId' is set
      if (customerId === undefined || customerId === null) {
        throw new Error("Missing the required parameter 'customerId' when calling getCustomerProfile");
      }

      let pathParams = {
        'applicationId': applicationId,
        'customerId': customerId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = ApplicationCustomer;
      return this.apiClient.callApi(
        '/v1/customers/{customerId}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get Customer Profile
     * @param {Number} applicationId 
     * @param {Number} customerId 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/ApplicationCustomer}
     */
    getCustomerProfile(applicationId, customerId) {
      return this.getCustomerProfileWithHttpInfo(applicationId, customerId)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * List Customer Profiles
     * @param {Object} opts Optional parameters
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/InlineResponse20013} and HTTP response
     */
    getCustomerProfilesWithHttpInfo(opts) {
      opts = opts || {};
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
        'pageSize': opts['pageSize'],
        'skip': opts['skip']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = InlineResponse20013;
      return this.apiClient.callApi(
        '/v1/customers/no_total', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * List Customer Profiles
     * @param {Object} opts Optional parameters
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/InlineResponse20013}
     */
    getCustomerProfiles(opts) {
      return this.getCustomerProfilesWithHttpInfo(opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get a list of the customer profiles that match the given attributes
     * Gets a list of all the customer profiles for the account that exactly match a set of attributes.  The match is successful if all the attributes of the request are found in a profile, even if the profile has more attributes that are not present on the request.  [Customer Profile]: https://help.talon.one/hc/en-us/articles/360005130739-Data-Model#CustomerProfile 
     * @param {module:model/ApplicationCustomerSearch} body 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/InlineResponse20013} and HTTP response
     */
    getCustomersByAttributesWithHttpInfo(body, opts) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling getCustomersByAttributes");
      }

      let pathParams = {
      };
      let queryParams = {
        'pageSize': opts['pageSize'],
        'skip': opts['skip']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = InlineResponse20013;
      return this.apiClient.callApi(
        '/v1/customer_search/no_total', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get a list of the customer profiles that match the given attributes
     * Gets a list of all the customer profiles for the account that exactly match a set of attributes.  The match is successful if all the attributes of the request are found in a profile, even if the profile has more attributes that are not present on the request.  [Customer Profile]: https://help.talon.one/hc/en-us/articles/360005130739-Data-Model#CustomerProfile 
     * @param {module:model/ApplicationCustomerSearch} body 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/InlineResponse20013}
     */
    getCustomersByAttributes(body, opts) {
      return this.getCustomersByAttributesWithHttpInfo(body, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * List Event Types
     * Fetch all event type definitions for your account. Each event type can be 
     * @param {Object} opts Optional parameters
     * @param {String} opts.applicationIds Filter by one or more application ids separated by comma
     * @param {String} opts.name Filter results to event types with the given name. This parameter implies `includeOldVersions`.
     * @param {Boolean} opts.includeOldVersions Include all versions of every event type. (default to false)
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @param {String} opts.sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/InlineResponse20025} and HTTP response
     */
    getEventTypesWithHttpInfo(opts) {
      opts = opts || {};
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
        'applicationIds': opts['applicationIds'],
        'name': opts['name'],
        'includeOldVersions': opts['includeOldVersions'],
        'pageSize': opts['pageSize'],
        'skip': opts['skip'],
        'sort': opts['sort']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = InlineResponse20025;
      return this.apiClient.callApi(
        '/v1/event_types', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * List Event Types
     * Fetch all event type definitions for your account. Each event type can be 
     * @param {Object} opts Optional parameters
     * @param {String} opts.applicationIds Filter by one or more application ids separated by comma
     * @param {String} opts.name Filter results to event types with the given name. This parameter implies `includeOldVersions`.
     * @param {Boolean} opts.includeOldVersions Include all versions of every event type. (default to false)
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @param {String} opts.sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/InlineResponse20025}
     */
    getEventTypes(opts) {
      return this.getEventTypesWithHttpInfo(opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get Exports
     * Get a list of all past exports 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @param {Number} opts.applicationId 
     * @param {Number} opts.campaignId 
     * @param {module:model/String} opts.entity The name of the entity type that was exported.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/InlineResponse20028} and HTTP response
     */
    getExportsWithHttpInfo(opts) {
      opts = opts || {};
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
        'pageSize': opts['pageSize'],
        'skip': opts['skip'],
        'applicationId': opts['applicationId'],
        'campaignId': opts['campaignId'],
        'entity': opts['entity']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = InlineResponse20028;
      return this.apiClient.callApi(
        '/v1/exports', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get Exports
     * Get a list of all past exports 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @param {Number} opts.applicationId 
     * @param {Number} opts.campaignId 
     * @param {module:model/String} opts.entity The name of the entity type that was exported.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/InlineResponse20028}
     */
    getExports(opts) {
      return this.getExportsWithHttpInfo(opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get Imports
     * Get a list of all past imports 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/InlineResponse20029} and HTTP response
     */
    getImportsWithHttpInfo(opts) {
      opts = opts || {};
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
        'pageSize': opts['pageSize'],
        'skip': opts['skip']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = InlineResponse20029;
      return this.apiClient.callApi(
        '/v1/imports', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get Imports
     * Get a list of all past imports 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/InlineResponse20029}
     */
    getImports(opts) {
      return this.getImportsWithHttpInfo(opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * get the Loyalty Ledger for this integrationID
     * Get the Loyalty Ledger for this profile integration ID.
     * @param {String} programID The identifier for the application, must be unique within the account.
     * @param {String} integrationID The identifier for the application, must be unique within the account.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/LoyaltyLedger} and HTTP response
     */
    getLoyaltyPointsWithHttpInfo(programID, integrationID) {
      let postBody = null;
      // verify the required parameter 'programID' is set
      if (programID === undefined || programID === null) {
        throw new Error("Missing the required parameter 'programID' when calling getLoyaltyPoints");
      }
      // verify the required parameter 'integrationID' is set
      if (integrationID === undefined || integrationID === null) {
        throw new Error("Missing the required parameter 'integrationID' when calling getLoyaltyPoints");
      }

      let pathParams = {
        'programID': programID,
        'integrationID': integrationID
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = LoyaltyLedger;
      return this.apiClient.callApi(
        '/v1/loyalty_programs/{programID}/profile/{integrationID}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * get the Loyalty Ledger for this integrationID
     * Get the Loyalty Ledger for this profile integration ID.
     * @param {String} programID The identifier for the application, must be unique within the account.
     * @param {String} integrationID The identifier for the application, must be unique within the account.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/LoyaltyLedger}
     */
    getLoyaltyPoints(programID, integrationID) {
      return this.getLoyaltyPointsWithHttpInfo(programID, integrationID)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get a loyalty program
     * @param {String} programID 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/LoyaltyProgram} and HTTP response
     */
    getLoyaltyProgramWithHttpInfo(programID) {
      let postBody = null;
      // verify the required parameter 'programID' is set
      if (programID === undefined || programID === null) {
        throw new Error("Missing the required parameter 'programID' when calling getLoyaltyProgram");
      }

      let pathParams = {
        'programID': programID
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = LoyaltyProgram;
      return this.apiClient.callApi(
        '/v1/loyalty_programs/{programID}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get a loyalty program
     * @param {String} programID 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/LoyaltyProgram}
     */
    getLoyaltyProgram(programID) {
      return this.getLoyaltyProgramWithHttpInfo(programID)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * List all loyalty Programs
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/InlineResponse2008} and HTTP response
     */
    getLoyaltyProgramsWithHttpInfo() {
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = InlineResponse2008;
      return this.apiClient.callApi(
        '/v1/loyalty_programs', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * List all loyalty Programs
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/InlineResponse2008}
     */
    getLoyaltyPrograms() {
      return this.getLoyaltyProgramsWithHttpInfo()
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * List Referrals
     * @param {Number} applicationId 
     * @param {Number} campaignId 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @param {String} opts.sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
     * @param {String} opts.code Filter results performing case-insensitive matching against the referral code. Both the code and the query are folded to remove all non-alpha-numeric characters.
     * @param {Date} opts.createdBefore Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the referral creation timestamp.
     * @param {Date} opts.createdAfter Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the referral creation timestamp.
     * @param {module:model/String} opts.valid Either \"expired\", \"validNow\", or \"validFuture\". The first option matches referrals in which the expiry date is set and in the past. The second matches referrals in which start date is null or in the past and expiry date is null or in the future, the third matches referrals in which start date is set and in the future. 
     * @param {module:model/String} opts.usable Either \"true\" or \"false\". If \"true\", only referrals where `usageCounter < usageLimit` will be returned, \"false\" will return only referrals where `usageCounter >= usageLimit`. 
     * @param {String} opts.advocate Filter results by match with a profile id specified in the referral's AdvocateProfileIntegrationId field
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/InlineResponse2006} and HTTP response
     */
    getReferralsWithHttpInfo(applicationId, campaignId, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'applicationId' is set
      if (applicationId === undefined || applicationId === null) {
        throw new Error("Missing the required parameter 'applicationId' when calling getReferrals");
      }
      // verify the required parameter 'campaignId' is set
      if (campaignId === undefined || campaignId === null) {
        throw new Error("Missing the required parameter 'campaignId' when calling getReferrals");
      }

      let pathParams = {
        'applicationId': applicationId,
        'campaignId': campaignId
      };
      let queryParams = {
        'pageSize': opts['pageSize'],
        'skip': opts['skip'],
        'sort': opts['sort'],
        'code': opts['code'],
        'createdBefore': opts['createdBefore'],
        'createdAfter': opts['createdAfter'],
        'valid': opts['valid'],
        'usable': opts['usable'],
        'advocate': opts['advocate']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = InlineResponse2006;
      return this.apiClient.callApi(
        '/v1/applications/{applicationId}/campaigns/{campaignId}/referrals', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * List Referrals
     * @param {Number} applicationId 
     * @param {Number} campaignId 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @param {String} opts.sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
     * @param {String} opts.code Filter results performing case-insensitive matching against the referral code. Both the code and the query are folded to remove all non-alpha-numeric characters.
     * @param {Date} opts.createdBefore Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the referral creation timestamp.
     * @param {Date} opts.createdAfter Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the referral creation timestamp.
     * @param {module:model/String} opts.valid Either \"expired\", \"validNow\", or \"validFuture\". The first option matches referrals in which the expiry date is set and in the past. The second matches referrals in which start date is null or in the past and expiry date is null or in the future, the third matches referrals in which start date is set and in the future. 
     * @param {module:model/String} opts.usable Either \"true\" or \"false\". If \"true\", only referrals where `usageCounter < usageLimit` will be returned, \"false\" will return only referrals where `usageCounter >= usageLimit`. 
     * @param {String} opts.advocate Filter results by match with a profile id specified in the referral's AdvocateProfileIntegrationId field
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/InlineResponse2006}
     */
    getReferrals(applicationId, campaignId, opts) {
      return this.getReferralsWithHttpInfo(applicationId, campaignId, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * List Referrals
     * @param {Number} applicationId 
     * @param {Number} campaignId 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @param {String} opts.sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
     * @param {String} opts.code Filter results performing case-insensitive matching against the referral code. Both the code and the query are folded to remove all non-alpha-numeric characters.
     * @param {Date} opts.createdBefore Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the referral creation timestamp.
     * @param {Date} opts.createdAfter Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the referral creation timestamp.
     * @param {module:model/String} opts.valid Either \"expired\", \"validNow\", or \"validFuture\". The first option matches referrals in which the expiry date is set and in the past. The second matches referrals in which start date is null or in the past and expiry date is null or in the future, the third matches referrals in which start date is set and in the future. 
     * @param {module:model/String} opts.usable Either \"true\" or \"false\". If \"true\", only referrals where `usageCounter < usageLimit` will be returned, \"false\" will return only referrals where `usageCounter >= usageLimit`. 
     * @param {String} opts.advocate Filter results by match with a profile id specified in the referral's AdvocateProfileIntegrationId field
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/InlineResponse2007} and HTTP response
     */
    getReferralsWithoutTotalCountWithHttpInfo(applicationId, campaignId, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'applicationId' is set
      if (applicationId === undefined || applicationId === null) {
        throw new Error("Missing the required parameter 'applicationId' when calling getReferralsWithoutTotalCount");
      }
      // verify the required parameter 'campaignId' is set
      if (campaignId === undefined || campaignId === null) {
        throw new Error("Missing the required parameter 'campaignId' when calling getReferralsWithoutTotalCount");
      }

      let pathParams = {
        'applicationId': applicationId,
        'campaignId': campaignId
      };
      let queryParams = {
        'pageSize': opts['pageSize'],
        'skip': opts['skip'],
        'sort': opts['sort'],
        'code': opts['code'],
        'createdBefore': opts['createdBefore'],
        'createdAfter': opts['createdAfter'],
        'valid': opts['valid'],
        'usable': opts['usable'],
        'advocate': opts['advocate']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = InlineResponse2007;
      return this.apiClient.callApi(
        '/v1/applications/{applicationId}/campaigns/{campaignId}/referrals/no_total', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * List Referrals
     * @param {Number} applicationId 
     * @param {Number} campaignId 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @param {String} opts.sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
     * @param {String} opts.code Filter results performing case-insensitive matching against the referral code. Both the code and the query are folded to remove all non-alpha-numeric characters.
     * @param {Date} opts.createdBefore Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the referral creation timestamp.
     * @param {Date} opts.createdAfter Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the referral creation timestamp.
     * @param {module:model/String} opts.valid Either \"expired\", \"validNow\", or \"validFuture\". The first option matches referrals in which the expiry date is set and in the past. The second matches referrals in which start date is null or in the past and expiry date is null or in the future, the third matches referrals in which start date is set and in the future. 
     * @param {module:model/String} opts.usable Either \"true\" or \"false\". If \"true\", only referrals where `usageCounter < usageLimit` will be returned, \"false\" will return only referrals where `usageCounter >= usageLimit`. 
     * @param {String} opts.advocate Filter results by match with a profile id specified in the referral's AdvocateProfileIntegrationId field
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/InlineResponse2007}
     */
    getReferralsWithoutTotalCount(applicationId, campaignId, opts) {
      return this.getReferralsWithoutTotalCountWithHttpInfo(applicationId, campaignId, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get information for the specified role.
     * @param {Number} roleId 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/Role} and HTTP response
     */
    getRoleWithHttpInfo(roleId) {
      let postBody = null;
      // verify the required parameter 'roleId' is set
      if (roleId === undefined || roleId === null) {
        throw new Error("Missing the required parameter 'roleId' when calling getRole");
      }

      let pathParams = {
        'roleId': roleId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = Role;
      return this.apiClient.callApi(
        '/v1/roles/{roleId}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get information for the specified role.
     * @param {Number} roleId 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/Role}
     */
    getRole(roleId) {
      return this.getRoleWithHttpInfo(roleId)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get a Ruleset
     * @param {Number} applicationId 
     * @param {Number} campaignId 
     * @param {Number} rulesetId 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/Ruleset} and HTTP response
     */
    getRulesetWithHttpInfo(applicationId, campaignId, rulesetId) {
      let postBody = null;
      // verify the required parameter 'applicationId' is set
      if (applicationId === undefined || applicationId === null) {
        throw new Error("Missing the required parameter 'applicationId' when calling getRuleset");
      }
      // verify the required parameter 'campaignId' is set
      if (campaignId === undefined || campaignId === null) {
        throw new Error("Missing the required parameter 'campaignId' when calling getRuleset");
      }
      // verify the required parameter 'rulesetId' is set
      if (rulesetId === undefined || rulesetId === null) {
        throw new Error("Missing the required parameter 'rulesetId' when calling getRuleset");
      }

      let pathParams = {
        'applicationId': applicationId,
        'campaignId': campaignId,
        'rulesetId': rulesetId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = Ruleset;
      return this.apiClient.callApi(
        '/v1/applications/{applicationId}/campaigns/{campaignId}/rulesets/{rulesetId}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get a Ruleset
     * @param {Number} applicationId 
     * @param {Number} campaignId 
     * @param {Number} rulesetId 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/Ruleset}
     */
    getRuleset(applicationId, campaignId, rulesetId) {
      return this.getRulesetWithHttpInfo(applicationId, campaignId, rulesetId)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * List Campaign Rulesets
     * @param {Number} applicationId 
     * @param {Number} campaignId 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @param {String} opts.sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/InlineResponse2004} and HTTP response
     */
    getRulesetsWithHttpInfo(applicationId, campaignId, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'applicationId' is set
      if (applicationId === undefined || applicationId === null) {
        throw new Error("Missing the required parameter 'applicationId' when calling getRulesets");
      }
      // verify the required parameter 'campaignId' is set
      if (campaignId === undefined || campaignId === null) {
        throw new Error("Missing the required parameter 'campaignId' when calling getRulesets");
      }

      let pathParams = {
        'applicationId': applicationId,
        'campaignId': campaignId
      };
      let queryParams = {
        'pageSize': opts['pageSize'],
        'skip': opts['skip'],
        'sort': opts['sort']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = InlineResponse2004;
      return this.apiClient.callApi(
        '/v1/applications/{applicationId}/campaigns/{campaignId}/rulesets', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * List Campaign Rulesets
     * @param {Number} applicationId 
     * @param {Number} campaignId 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @param {String} opts.sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/InlineResponse2004}
     */
    getRulesets(applicationId, campaignId, opts) {
      return this.getRulesetsWithHttpInfo(applicationId, campaignId, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get a single User
     * Retrieves the data (including an invitation code) for a user. Non-admin users can only get themselves. 
     * @param {Number} userId 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/User} and HTTP response
     */
    getUserWithHttpInfo(userId) {
      let postBody = null;
      // verify the required parameter 'userId' is set
      if (userId === undefined || userId === null) {
        throw new Error("Missing the required parameter 'userId' when calling getUser");
      }

      let pathParams = {
        'userId': userId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = User;
      return this.apiClient.callApi(
        '/v1/users/{userId}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get a single User
     * Retrieves the data (including an invitation code) for a user. Non-admin users can only get themselves. 
     * @param {Number} userId 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/User}
     */
    getUser(userId) {
      return this.getUserWithHttpInfo(userId)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * List Users in your account
     * Retrieve all users in your account. 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @param {String} opts.sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/InlineResponse20026} and HTTP response
     */
    getUsersWithHttpInfo(opts) {
      opts = opts || {};
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
        'pageSize': opts['pageSize'],
        'skip': opts['skip'],
        'sort': opts['sort']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = InlineResponse20026;
      return this.apiClient.callApi(
        '/v1/users', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * List Users in your account
     * Retrieve all users in your account. 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @param {String} opts.sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/InlineResponse20026}
     */
    getUsers(opts) {
      return this.getUsersWithHttpInfo(opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get Webhook
     * Returns an webhook by its id.
     * @param {Number} webhookId 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/Webhook} and HTTP response
     */
    getWebhookWithHttpInfo(webhookId) {
      let postBody = null;
      // verify the required parameter 'webhookId' is set
      if (webhookId === undefined || webhookId === null) {
        throw new Error("Missing the required parameter 'webhookId' when calling getWebhook");
      }

      let pathParams = {
        'webhookId': webhookId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = Webhook;
      return this.apiClient.callApi(
        '/v1/webhooks/{webhookId}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get Webhook
     * Returns an webhook by its id.
     * @param {Number} webhookId 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/Webhook}
     */
    getWebhook(webhookId) {
      return this.getWebhookWithHttpInfo(webhookId)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * List Webhook activation Log Entries
     * Webhook activation log entries would be created as soon as an integration request triggered an effect with a webhook
     * @param {Object} opts Optional parameters
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @param {String} opts.sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
     * @param {String} opts.integrationRequestUuid Filter results by integration request UUID.
     * @param {Number} opts.webhookId Filter results by Webhook.
     * @param {Number} opts.applicationId 
     * @param {Number} opts.campaignId Filter results by campaign.
     * @param {Date} opts.createdBefore Only return events created before this date.
     * @param {Date} opts.createdAfter Filter results where request and response times to return entries after parameter value, expected to be an RFC3339 timestamp string.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/InlineResponse20023} and HTTP response
     */
    getWebhookActivationLogsWithHttpInfo(opts) {
      opts = opts || {};
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
        'pageSize': opts['pageSize'],
        'skip': opts['skip'],
        'sort': opts['sort'],
        'integrationRequestUuid': opts['integrationRequestUuid'],
        'webhookId': opts['webhookId'],
        'applicationId': opts['applicationId'],
        'campaignId': opts['campaignId'],
        'createdBefore': opts['createdBefore'],
        'createdAfter': opts['createdAfter']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = InlineResponse20023;
      return this.apiClient.callApi(
        '/v1/webhook_activation_logs', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * List Webhook activation Log Entries
     * Webhook activation log entries would be created as soon as an integration request triggered an effect with a webhook
     * @param {Object} opts Optional parameters
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @param {String} opts.sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
     * @param {String} opts.integrationRequestUuid Filter results by integration request UUID.
     * @param {Number} opts.webhookId Filter results by Webhook.
     * @param {Number} opts.applicationId 
     * @param {Number} opts.campaignId Filter results by campaign.
     * @param {Date} opts.createdBefore Only return events created before this date.
     * @param {Date} opts.createdAfter Filter results where request and response times to return entries after parameter value, expected to be an RFC3339 timestamp string.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/InlineResponse20023}
     */
    getWebhookActivationLogs(opts) {
      return this.getWebhookActivationLogsWithHttpInfo(opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * List Webhook Log Entries
     * @param {Object} opts Optional parameters
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @param {String} opts.sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
     * @param {module:model/String} opts.status Filter results by HTTP status codes.
     * @param {Number} opts.webhookId Filter results by Webhook.
     * @param {Number} opts.applicationId 
     * @param {Number} opts.campaignId Filter results by campaign.
     * @param {String} opts.requestUuid Filter results by request UUID.
     * @param {Date} opts.createdBefore Filter results where request and response times to return entries before parameter value, expected to be an RFC3339 timestamp string.
     * @param {Date} opts.createdAfter Filter results where request and response times to return entries after parameter value, expected to be an RFC3339 timestamp string.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/InlineResponse20024} and HTTP response
     */
    getWebhookLogsWithHttpInfo(opts) {
      opts = opts || {};
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
        'pageSize': opts['pageSize'],
        'skip': opts['skip'],
        'sort': opts['sort'],
        'status': opts['status'],
        'webhookId': opts['webhookId'],
        'applicationId': opts['applicationId'],
        'campaignId': opts['campaignId'],
        'requestUuid': opts['requestUuid'],
        'createdBefore': opts['createdBefore'],
        'createdAfter': opts['createdAfter']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = InlineResponse20024;
      return this.apiClient.callApi(
        '/v1/webhook_logs', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * List Webhook Log Entries
     * @param {Object} opts Optional parameters
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @param {String} opts.sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
     * @param {module:model/String} opts.status Filter results by HTTP status codes.
     * @param {Number} opts.webhookId Filter results by Webhook.
     * @param {Number} opts.applicationId 
     * @param {Number} opts.campaignId Filter results by campaign.
     * @param {String} opts.requestUuid Filter results by request UUID.
     * @param {Date} opts.createdBefore Filter results where request and response times to return entries before parameter value, expected to be an RFC3339 timestamp string.
     * @param {Date} opts.createdAfter Filter results where request and response times to return entries after parameter value, expected to be an RFC3339 timestamp string.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/InlineResponse20024}
     */
    getWebhookLogs(opts) {
      return this.getWebhookLogsWithHttpInfo(opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * List Webhooks
     * @param {Object} opts Optional parameters
     * @param {String} opts.applicationIds Filter by one or more application ids separated by comma
     * @param {String} opts.sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/InlineResponse20022} and HTTP response
     */
    getWebhooksWithHttpInfo(opts) {
      opts = opts || {};
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
        'applicationIds': opts['applicationIds'],
        'sort': opts['sort'],
        'pageSize': opts['pageSize'],
        'skip': opts['skip']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = InlineResponse20022;
      return this.apiClient.callApi(
        '/v1/webhooks', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * List Webhooks
     * @param {Object} opts Optional parameters
     * @param {String} opts.applicationIds Filter by one or more application ids separated by comma
     * @param {String} opts.sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/InlineResponse20022}
     */
    getWebhooks(opts) {
      return this.getWebhooksWithHttpInfo(opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Deduct points in a certain loyalty program for the specified customer
     * @param {String} programID 
     * @param {String} integrationID 
     * @param {module:model/LoyaltyPoints} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing HTTP response
     */
    removeLoyaltyPointsWithHttpInfo(programID, integrationID, body) {
      let postBody = body;
      // verify the required parameter 'programID' is set
      if (programID === undefined || programID === null) {
        throw new Error("Missing the required parameter 'programID' when calling removeLoyaltyPoints");
      }
      // verify the required parameter 'integrationID' is set
      if (integrationID === undefined || integrationID === null) {
        throw new Error("Missing the required parameter 'integrationID' when calling removeLoyaltyPoints");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling removeLoyaltyPoints");
      }

      let pathParams = {
        'programID': programID,
        'integrationID': integrationID
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = ['application/json'];
      let accepts = [];
      let returnType = null;
      return this.apiClient.callApi(
        '/v1/loyalty_programs/{programID}/profile/{integrationID}/deduct_points', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Deduct points in a certain loyalty program for the specified customer
     * @param {String} programID 
     * @param {String} integrationID 
     * @param {module:model/LoyaltyPoints} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}
     */
    removeLoyaltyPoints(programID, integrationID, body) {
      return this.removeLoyaltyPointsWithHttpInfo(programID, integrationID, body)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Reset password
     * Consumes the supplied password reset token and updates the password for the associated account. 
     * @param {module:model/NewPassword} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/NewPassword} and HTTP response
     */
    resetPasswordWithHttpInfo(body) {
      let postBody = body;
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling resetPassword");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = NewPassword;
      return this.apiClient.callApi(
        '/v1/reset_password', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Reset password
     * Consumes the supplied password reset token and updates the password for the associated account. 
     * @param {module:model/NewPassword} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/NewPassword}
     */
    resetPassword(body) {
      return this.resetPasswordWithHttpInfo(body)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get a list of the coupons that match the given attributes
     * Gets a list of all the coupons with attributes matching the query criteria 
     * @param {Number} applicationId 
     * @param {Number} campaignId 
     * @param {Object} body 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @param {String} opts.sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
     * @param {String} opts.value Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters.
     * @param {Date} opts.createdBefore Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
     * @param {Date} opts.createdAfter Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
     * @param {module:model/String} opts.valid Either \"expired\", \"validNow\", or \"validFuture\". The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. 
     * @param {module:model/String} opts.usable Either \"true\" or \"false\". If \"true\", only coupons where `usageCounter < usageLimit` will be returned, \"false\" will return only coupons where `usageCounter >= usageLimit`. 
     * @param {Number} opts.referralId Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code.
     * @param {String} opts.recipientIntegrationId Filter results by match with a profile id specified in the coupon's RecipientIntegrationId field
     * @param {Boolean} opts.exactMatch Filter results to an exact case-insensitive matching against the coupon code (default to false)
     * @param {String} opts.batchId Filter results by batches of coupons
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/InlineResponse2001} and HTTP response
     */
    searchCouponsAdvancedWithHttpInfo(applicationId, campaignId, body, opts) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'applicationId' is set
      if (applicationId === undefined || applicationId === null) {
        throw new Error("Missing the required parameter 'applicationId' when calling searchCouponsAdvanced");
      }
      // verify the required parameter 'campaignId' is set
      if (campaignId === undefined || campaignId === null) {
        throw new Error("Missing the required parameter 'campaignId' when calling searchCouponsAdvanced");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling searchCouponsAdvanced");
      }

      let pathParams = {
        'applicationId': applicationId,
        'campaignId': campaignId
      };
      let queryParams = {
        'pageSize': opts['pageSize'],
        'skip': opts['skip'],
        'sort': opts['sort'],
        'value': opts['value'],
        'createdBefore': opts['createdBefore'],
        'createdAfter': opts['createdAfter'],
        'valid': opts['valid'],
        'usable': opts['usable'],
        'referralId': opts['referralId'],
        'recipientIntegrationId': opts['recipientIntegrationId'],
        'exactMatch': opts['exactMatch'],
        'batchId': opts['batchId']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = InlineResponse2001;
      return this.apiClient.callApi(
        '/v1/applications/{applicationId}/campaigns/{campaignId}/coupons_search_advanced', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get a list of the coupons that match the given attributes
     * Gets a list of all the coupons with attributes matching the query criteria 
     * @param {Number} applicationId 
     * @param {Number} campaignId 
     * @param {Object} body 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @param {String} opts.sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
     * @param {String} opts.value Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters.
     * @param {Date} opts.createdBefore Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
     * @param {Date} opts.createdAfter Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
     * @param {module:model/String} opts.valid Either \"expired\", \"validNow\", or \"validFuture\". The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. 
     * @param {module:model/String} opts.usable Either \"true\" or \"false\". If \"true\", only coupons where `usageCounter < usageLimit` will be returned, \"false\" will return only coupons where `usageCounter >= usageLimit`. 
     * @param {Number} opts.referralId Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code.
     * @param {String} opts.recipientIntegrationId Filter results by match with a profile id specified in the coupon's RecipientIntegrationId field
     * @param {Boolean} opts.exactMatch Filter results to an exact case-insensitive matching against the coupon code (default to false)
     * @param {String} opts.batchId Filter results by batches of coupons
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/InlineResponse2001}
     */
    searchCouponsAdvanced(applicationId, campaignId, body, opts) {
      return this.searchCouponsAdvancedWithHttpInfo(applicationId, campaignId, body, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get a list of the coupons that match the given attributes in all active campaigns of an application
     * Gets a list of all the coupons with attributes matching the query criteria in all active campaigns of an application 
     * @param {Number} applicationId 
     * @param {Object} body 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @param {String} opts.sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
     * @param {String} opts.value Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters.
     * @param {Date} opts.createdBefore Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
     * @param {Date} opts.createdAfter Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
     * @param {module:model/String} opts.valid Either \"expired\", \"validNow\", or \"validFuture\". The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. 
     * @param {module:model/String} opts.usable Either \"true\" or \"false\". If \"true\", only coupons where `usageCounter < usageLimit` will be returned, \"false\" will return only coupons where `usageCounter >= usageLimit`. 
     * @param {Number} opts.referralId Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code.
     * @param {String} opts.recipientIntegrationId Filter results by match with a profile id specified in the coupon's RecipientIntegrationId field
     * @param {String} opts.batchId Filter results by batches of coupons
     * @param {Boolean} opts.exactMatch Filter results to an exact case-insensitive matching against the coupon code (default to false)
     * @param {module:model/String} opts.campaignState Filter results by the state of the campaign.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/InlineResponse2001} and HTTP response
     */
    searchCouponsAdvancedApplicationWideWithHttpInfo(applicationId, body, opts) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'applicationId' is set
      if (applicationId === undefined || applicationId === null) {
        throw new Error("Missing the required parameter 'applicationId' when calling searchCouponsAdvancedApplicationWide");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling searchCouponsAdvancedApplicationWide");
      }

      let pathParams = {
        'applicationId': applicationId
      };
      let queryParams = {
        'pageSize': opts['pageSize'],
        'skip': opts['skip'],
        'sort': opts['sort'],
        'value': opts['value'],
        'createdBefore': opts['createdBefore'],
        'createdAfter': opts['createdAfter'],
        'valid': opts['valid'],
        'usable': opts['usable'],
        'referralId': opts['referralId'],
        'recipientIntegrationId': opts['recipientIntegrationId'],
        'batchId': opts['batchId'],
        'exactMatch': opts['exactMatch'],
        'campaignState': opts['campaignState']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = InlineResponse2001;
      return this.apiClient.callApi(
        '/v1/applications/{applicationId}/coupons_search_advanced', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get a list of the coupons that match the given attributes in all active campaigns of an application
     * Gets a list of all the coupons with attributes matching the query criteria in all active campaigns of an application 
     * @param {Number} applicationId 
     * @param {Object} body 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @param {String} opts.sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
     * @param {String} opts.value Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters.
     * @param {Date} opts.createdBefore Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
     * @param {Date} opts.createdAfter Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
     * @param {module:model/String} opts.valid Either \"expired\", \"validNow\", or \"validFuture\". The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. 
     * @param {module:model/String} opts.usable Either \"true\" or \"false\". If \"true\", only coupons where `usageCounter < usageLimit` will be returned, \"false\" will return only coupons where `usageCounter >= usageLimit`. 
     * @param {Number} opts.referralId Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code.
     * @param {String} opts.recipientIntegrationId Filter results by match with a profile id specified in the coupon's RecipientIntegrationId field
     * @param {String} opts.batchId Filter results by batches of coupons
     * @param {Boolean} opts.exactMatch Filter results to an exact case-insensitive matching against the coupon code (default to false)
     * @param {module:model/String} opts.campaignState Filter results by the state of the campaign.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/InlineResponse2001}
     */
    searchCouponsAdvancedApplicationWide(applicationId, body, opts) {
      return this.searchCouponsAdvancedApplicationWideWithHttpInfo(applicationId, body, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get a list of the coupons that match the given attributes in all active campaigns of an application
     * Gets a list of all the coupons with attributes matching the query criteria in all active campaigns of an application 
     * @param {Number} applicationId 
     * @param {Object} body 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @param {String} opts.sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
     * @param {String} opts.value Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters.
     * @param {Date} opts.createdBefore Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
     * @param {Date} opts.createdAfter Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
     * @param {module:model/String} opts.valid Either \"expired\", \"validNow\", or \"validFuture\". The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. 
     * @param {module:model/String} opts.usable Either \"true\" or \"false\". If \"true\", only coupons where `usageCounter < usageLimit` will be returned, \"false\" will return only coupons where `usageCounter >= usageLimit`. 
     * @param {Number} opts.referralId Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code.
     * @param {String} opts.recipientIntegrationId Filter results by match with a profile id specified in the coupon's RecipientIntegrationId field
     * @param {String} opts.batchId Filter results by batches of coupons
     * @param {Boolean} opts.exactMatch Filter results to an exact case-insensitive matching against the coupon code (default to false)
     * @param {module:model/String} opts.campaignState Filter results by the state of the campaign.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/InlineResponse2005} and HTTP response
     */
    searchCouponsAdvancedApplicationWideWithoutTotalCountWithHttpInfo(applicationId, body, opts) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'applicationId' is set
      if (applicationId === undefined || applicationId === null) {
        throw new Error("Missing the required parameter 'applicationId' when calling searchCouponsAdvancedApplicationWideWithoutTotalCount");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling searchCouponsAdvancedApplicationWideWithoutTotalCount");
      }

      let pathParams = {
        'applicationId': applicationId
      };
      let queryParams = {
        'pageSize': opts['pageSize'],
        'skip': opts['skip'],
        'sort': opts['sort'],
        'value': opts['value'],
        'createdBefore': opts['createdBefore'],
        'createdAfter': opts['createdAfter'],
        'valid': opts['valid'],
        'usable': opts['usable'],
        'referralId': opts['referralId'],
        'recipientIntegrationId': opts['recipientIntegrationId'],
        'batchId': opts['batchId'],
        'exactMatch': opts['exactMatch'],
        'campaignState': opts['campaignState']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = InlineResponse2005;
      return this.apiClient.callApi(
        '/v1/applications/{applicationId}/coupons_search_advanced/no_total', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get a list of the coupons that match the given attributes in all active campaigns of an application
     * Gets a list of all the coupons with attributes matching the query criteria in all active campaigns of an application 
     * @param {Number} applicationId 
     * @param {Object} body 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @param {String} opts.sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
     * @param {String} opts.value Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters.
     * @param {Date} opts.createdBefore Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
     * @param {Date} opts.createdAfter Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
     * @param {module:model/String} opts.valid Either \"expired\", \"validNow\", or \"validFuture\". The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. 
     * @param {module:model/String} opts.usable Either \"true\" or \"false\". If \"true\", only coupons where `usageCounter < usageLimit` will be returned, \"false\" will return only coupons where `usageCounter >= usageLimit`. 
     * @param {Number} opts.referralId Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code.
     * @param {String} opts.recipientIntegrationId Filter results by match with a profile id specified in the coupon's RecipientIntegrationId field
     * @param {String} opts.batchId Filter results by batches of coupons
     * @param {Boolean} opts.exactMatch Filter results to an exact case-insensitive matching against the coupon code (default to false)
     * @param {module:model/String} opts.campaignState Filter results by the state of the campaign.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/InlineResponse2005}
     */
    searchCouponsAdvancedApplicationWideWithoutTotalCount(applicationId, body, opts) {
      return this.searchCouponsAdvancedApplicationWideWithoutTotalCountWithHttpInfo(applicationId, body, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get a list of the coupons that match the given attributes
     * Gets a list of all the coupons with attributes matching the query criteria 
     * @param {Number} applicationId 
     * @param {Number} campaignId 
     * @param {Object} body 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @param {String} opts.sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
     * @param {String} opts.value Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters.
     * @param {Date} opts.createdBefore Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
     * @param {Date} opts.createdAfter Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
     * @param {module:model/String} opts.valid Either \"expired\", \"validNow\", or \"validFuture\". The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. 
     * @param {module:model/String} opts.usable Either \"true\" or \"false\". If \"true\", only coupons where `usageCounter < usageLimit` will be returned, \"false\" will return only coupons where `usageCounter >= usageLimit`. 
     * @param {Number} opts.referralId Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code.
     * @param {String} opts.recipientIntegrationId Filter results by match with a profile id specified in the coupon's RecipientIntegrationId field
     * @param {Boolean} opts.exactMatch Filter results to an exact case-insensitive matching against the coupon code (default to false)
     * @param {String} opts.batchId Filter results by batches of coupons
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/InlineResponse2005} and HTTP response
     */
    searchCouponsAdvancedWithoutTotalCountWithHttpInfo(applicationId, campaignId, body, opts) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'applicationId' is set
      if (applicationId === undefined || applicationId === null) {
        throw new Error("Missing the required parameter 'applicationId' when calling searchCouponsAdvancedWithoutTotalCount");
      }
      // verify the required parameter 'campaignId' is set
      if (campaignId === undefined || campaignId === null) {
        throw new Error("Missing the required parameter 'campaignId' when calling searchCouponsAdvancedWithoutTotalCount");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling searchCouponsAdvancedWithoutTotalCount");
      }

      let pathParams = {
        'applicationId': applicationId,
        'campaignId': campaignId
      };
      let queryParams = {
        'pageSize': opts['pageSize'],
        'skip': opts['skip'],
        'sort': opts['sort'],
        'value': opts['value'],
        'createdBefore': opts['createdBefore'],
        'createdAfter': opts['createdAfter'],
        'valid': opts['valid'],
        'usable': opts['usable'],
        'referralId': opts['referralId'],
        'recipientIntegrationId': opts['recipientIntegrationId'],
        'exactMatch': opts['exactMatch'],
        'batchId': opts['batchId']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = InlineResponse2005;
      return this.apiClient.callApi(
        '/v1/applications/{applicationId}/campaigns/{campaignId}/coupons_search_advanced/no_total', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get a list of the coupons that match the given attributes
     * Gets a list of all the coupons with attributes matching the query criteria 
     * @param {Number} applicationId 
     * @param {Number} campaignId 
     * @param {Object} body 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.pageSize The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
     * @param {Number} opts.skip Skips the given number of items when paging through large result sets.
     * @param {String} opts.sort The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
     * @param {String} opts.value Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters.
     * @param {Date} opts.createdBefore Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
     * @param {Date} opts.createdAfter Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
     * @param {module:model/String} opts.valid Either \"expired\", \"validNow\", or \"validFuture\". The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. 
     * @param {module:model/String} opts.usable Either \"true\" or \"false\". If \"true\", only coupons where `usageCounter < usageLimit` will be returned, \"false\" will return only coupons where `usageCounter >= usageLimit`. 
     * @param {Number} opts.referralId Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code.
     * @param {String} opts.recipientIntegrationId Filter results by match with a profile id specified in the coupon's RecipientIntegrationId field
     * @param {Boolean} opts.exactMatch Filter results to an exact case-insensitive matching against the coupon code (default to false)
     * @param {String} opts.batchId Filter results by batches of coupons
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/InlineResponse2005}
     */
    searchCouponsAdvancedWithoutTotalCount(applicationId, campaignId, body, opts) {
      return this.searchCouponsAdvancedWithoutTotalCountWithHttpInfo(applicationId, campaignId, body, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Update an additional cost
     * Updates an existing additional cost. Once created, the only property of an additional cost that can be changed is the title (human readable description). This restriction is in place to prevent accidentally breaking live integrations. 
     * @param {Number} additionalCostId 
     * @param {module:model/NewAdditionalCost} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/AccountAdditionalCost} and HTTP response
     */
    updateAdditionalCostWithHttpInfo(additionalCostId, body) {
      let postBody = body;
      // verify the required parameter 'additionalCostId' is set
      if (additionalCostId === undefined || additionalCostId === null) {
        throw new Error("Missing the required parameter 'additionalCostId' when calling updateAdditionalCost");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling updateAdditionalCost");
      }

      let pathParams = {
        'additionalCostId': additionalCostId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = AccountAdditionalCost;
      return this.apiClient.callApi(
        '/v1/additional_costs/{additionalCostId}', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Update an additional cost
     * Updates an existing additional cost. Once created, the only property of an additional cost that can be changed is the title (human readable description). This restriction is in place to prevent accidentally breaking live integrations. 
     * @param {Number} additionalCostId 
     * @param {module:model/NewAdditionalCost} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/AccountAdditionalCost}
     */
    updateAdditionalCost(additionalCostId, body) {
      return this.updateAdditionalCostWithHttpInfo(additionalCostId, body)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Update a custom attribute
     * Updates an existing custom attribute. Once created, the only property of a custom attribute that can be changed is the title (human readable description). This restriction is in place to prevent accidentally breaking live integrations. E.g. if you have a customer profile attribute with the name `region`, and your integration is sending `attributes.region` with customer profile updates, changing the name to `locale` would cause the integration requests to begin failing.  If you **really** need to change the `type` or `name` property of a custom attribute, create a new attribute and update any relevant integrations and rules to use the new attribute. Then delete the old attribute when you are confident you have migrated any needed data from the old attribute to the new one. 
     * @param {Number} attributeId 
     * @param {module:model/NewAttribute} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/Attribute} and HTTP response
     */
    updateAttributeWithHttpInfo(attributeId, body) {
      let postBody = body;
      // verify the required parameter 'attributeId' is set
      if (attributeId === undefined || attributeId === null) {
        throw new Error("Missing the required parameter 'attributeId' when calling updateAttribute");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling updateAttribute");
      }

      let pathParams = {
        'attributeId': attributeId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = Attribute;
      return this.apiClient.callApi(
        '/v1/attributes/{attributeId}', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Update a custom attribute
     * Updates an existing custom attribute. Once created, the only property of a custom attribute that can be changed is the title (human readable description). This restriction is in place to prevent accidentally breaking live integrations. E.g. if you have a customer profile attribute with the name `region`, and your integration is sending `attributes.region` with customer profile updates, changing the name to `locale` would cause the integration requests to begin failing.  If you **really** need to change the `type` or `name` property of a custom attribute, create a new attribute and update any relevant integrations and rules to use the new attribute. Then delete the old attribute when you are confident you have migrated any needed data from the old attribute to the new one. 
     * @param {Number} attributeId 
     * @param {module:model/NewAttribute} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/Attribute}
     */
    updateAttribute(attributeId, body) {
      return this.updateAttributeWithHttpInfo(attributeId, body)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Update a Campaign
     * @param {Number} applicationId 
     * @param {Number} campaignId 
     * @param {module:model/UpdateCampaign} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/Campaign} and HTTP response
     */
    updateCampaignWithHttpInfo(applicationId, campaignId, body) {
      let postBody = body;
      // verify the required parameter 'applicationId' is set
      if (applicationId === undefined || applicationId === null) {
        throw new Error("Missing the required parameter 'applicationId' when calling updateCampaign");
      }
      // verify the required parameter 'campaignId' is set
      if (campaignId === undefined || campaignId === null) {
        throw new Error("Missing the required parameter 'campaignId' when calling updateCampaign");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling updateCampaign");
      }

      let pathParams = {
        'applicationId': applicationId,
        'campaignId': campaignId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = Campaign;
      return this.apiClient.callApi(
        '/v1/applications/{applicationId}/campaigns/{campaignId}', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Update a Campaign
     * @param {Number} applicationId 
     * @param {Number} campaignId 
     * @param {module:model/UpdateCampaign} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/Campaign}
     */
    updateCampaign(applicationId, campaignId, body) {
      return this.updateCampaignWithHttpInfo(applicationId, campaignId, body)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Update a Campaign Set
     * @param {Number} applicationId 
     * @param {module:model/NewCampaignSet} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/CampaignSet} and HTTP response
     */
    updateCampaignSetWithHttpInfo(applicationId, body) {
      let postBody = body;
      // verify the required parameter 'applicationId' is set
      if (applicationId === undefined || applicationId === null) {
        throw new Error("Missing the required parameter 'applicationId' when calling updateCampaignSet");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling updateCampaignSet");
      }

      let pathParams = {
        'applicationId': applicationId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = CampaignSet;
      return this.apiClient.callApi(
        '/v1/applications/{applicationId}/campaign_set', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Update a Campaign Set
     * @param {Number} applicationId 
     * @param {module:model/NewCampaignSet} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/CampaignSet}
     */
    updateCampaignSet(applicationId, body) {
      return this.updateCampaignSetWithHttpInfo(applicationId, body)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Update a Coupon
     * @param {Number} applicationId 
     * @param {Number} campaignId 
     * @param {String} couponId The ID of the coupon code to update
     * @param {module:model/UpdateCoupon} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/Coupon} and HTTP response
     */
    updateCouponWithHttpInfo(applicationId, campaignId, couponId, body) {
      let postBody = body;
      // verify the required parameter 'applicationId' is set
      if (applicationId === undefined || applicationId === null) {
        throw new Error("Missing the required parameter 'applicationId' when calling updateCoupon");
      }
      // verify the required parameter 'campaignId' is set
      if (campaignId === undefined || campaignId === null) {
        throw new Error("Missing the required parameter 'campaignId' when calling updateCoupon");
      }
      // verify the required parameter 'couponId' is set
      if (couponId === undefined || couponId === null) {
        throw new Error("Missing the required parameter 'couponId' when calling updateCoupon");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling updateCoupon");
      }

      let pathParams = {
        'applicationId': applicationId,
        'campaignId': campaignId,
        'couponId': couponId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = Coupon;
      return this.apiClient.callApi(
        '/v1/applications/{applicationId}/campaigns/{campaignId}/coupons/{couponId}', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Update a Coupon
     * @param {Number} applicationId 
     * @param {Number} campaignId 
     * @param {String} couponId The ID of the coupon code to update
     * @param {module:model/UpdateCoupon} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/Coupon}
     */
    updateCoupon(applicationId, campaignId, couponId, body) {
      return this.updateCouponWithHttpInfo(applicationId, campaignId, couponId, body)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Update a Batch of Coupons
     * @param {Number} applicationId 
     * @param {Number} campaignId 
     * @param {module:model/UpdateCouponBatch} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing HTTP response
     */
    updateCouponBatchWithHttpInfo(applicationId, campaignId, body) {
      let postBody = body;
      // verify the required parameter 'applicationId' is set
      if (applicationId === undefined || applicationId === null) {
        throw new Error("Missing the required parameter 'applicationId' when calling updateCouponBatch");
      }
      // verify the required parameter 'campaignId' is set
      if (campaignId === undefined || campaignId === null) {
        throw new Error("Missing the required parameter 'campaignId' when calling updateCouponBatch");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling updateCouponBatch");
      }

      let pathParams = {
        'applicationId': applicationId,
        'campaignId': campaignId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = ['application/json'];
      let accepts = [];
      let returnType = null;
      return this.apiClient.callApi(
        '/v1/applications/{applicationId}/campaigns/{campaignId}/coupons', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Update a Batch of Coupons
     * @param {Number} applicationId 
     * @param {Number} campaignId 
     * @param {module:model/UpdateCouponBatch} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}
     */
    updateCouponBatch(applicationId, campaignId, body) {
      return this.updateCouponBatchWithHttpInfo(applicationId, campaignId, body)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Update a Ruleset
     * @param {Number} applicationId 
     * @param {Number} campaignId 
     * @param {Number} rulesetId 
     * @param {module:model/NewRuleset} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/Ruleset} and HTTP response
     */
    updateRulesetWithHttpInfo(applicationId, campaignId, rulesetId, body) {
      let postBody = body;
      // verify the required parameter 'applicationId' is set
      if (applicationId === undefined || applicationId === null) {
        throw new Error("Missing the required parameter 'applicationId' when calling updateRuleset");
      }
      // verify the required parameter 'campaignId' is set
      if (campaignId === undefined || campaignId === null) {
        throw new Error("Missing the required parameter 'campaignId' when calling updateRuleset");
      }
      // verify the required parameter 'rulesetId' is set
      if (rulesetId === undefined || rulesetId === null) {
        throw new Error("Missing the required parameter 'rulesetId' when calling updateRuleset");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling updateRuleset");
      }

      let pathParams = {
        'applicationId': applicationId,
        'campaignId': campaignId,
        'rulesetId': rulesetId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['manager_auth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = Ruleset;
      return this.apiClient.callApi(
        '/v1/applications/{applicationId}/campaigns/{campaignId}/rulesets/{rulesetId}', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Update a Ruleset
     * @param {Number} applicationId 
     * @param {Number} campaignId 
     * @param {Number} rulesetId 
     * @param {module:model/NewRuleset} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/Ruleset}
     */
    updateRuleset(applicationId, campaignId, rulesetId, body) {
      return this.updateRulesetWithHttpInfo(applicationId, campaignId, rulesetId, body)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


}
